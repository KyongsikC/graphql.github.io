{"version":3,"file":"58643b3b-96748c8c87a102bade0b.js","mappings":"quBAYA,SAASA,EAAaC,GAAW,IAAIC,EAErC,WAAuC,GAAuB,oBAAZC,UAA4BA,QAAQC,UAAW,OAAO,EAAO,GAAID,QAAQC,UAAUC,KAAM,OAAO,EAAO,GAAqB,mBAAVC,MAAsB,OAAO,EAAM,IAAsF,OAAhFC,QAAQC,UAAUC,QAAQC,KAAKP,QAAQC,UAAUG,QAAS,IAAI,iBAAyB,EAAQ,MAAOI,GAAK,OAAO,GAF9PC,GAA6B,OAAO,WAAkC,IAAsCC,EAAlCC,GAAQ,OAAgBb,GAAkB,GAAIC,EAA2B,CAAE,IAAIa,GAAY,OAAgBC,MAAMC,YAAaJ,EAASV,QAAQC,UAAUU,EAAOI,UAAWH,QAAqBF,EAASC,EAAMK,MAAMH,KAAME,WAAc,OAAO,OAA2BF,KAAMH,IAI5Z,SAASO,EAA2BC,EAAGC,GAAkB,IAAIC,EAAuB,oBAAXC,QAA0BH,EAAEG,OAAOC,WAAaJ,EAAE,cAAe,IAAKE,EAAI,CAAE,GAAIG,MAAMC,QAAQN,KAAOE,EAE9K,SAAqCF,EAAGO,GAAU,IAAKP,EAAG,OAAQ,GAAiB,iBAANA,EAAgB,OAAOQ,EAAkBR,EAAGO,GAAS,IAAIE,EAAIC,OAAOvB,UAAUwB,SAAStB,KAAKW,GAAGY,MAAM,GAAI,GAAc,WAANH,GAAkBT,EAAEJ,cAAaa,EAAIT,EAAEJ,YAAYiB,MAAM,GAAU,QAANJ,GAAqB,QAANA,EAAa,OAAOJ,MAAMS,KAAKd,GAAI,GAAU,cAANS,GAAqB,2CAA2CM,KAAKN,GAAI,OAAOD,EAAkBR,EAAGO,GAFnOS,CAA4BhB,KAAOC,GAAkBD,GAAyB,iBAAbA,EAAEiB,OAAqB,CAAMf,IAAIF,EAAIE,GAAI,IAAIgB,EAAI,EAAOC,EAAI,aAAiB,MAAO,CAAEC,EAAGD,EAAGV,EAAG,WAAe,OAAIS,GAAKlB,EAAEiB,OAAe,CAAEI,MAAM,GAAe,CAAEA,MAAM,EAAOC,MAAOtB,EAAEkB,OAAW5B,EAAG,SAAWiC,GAAM,MAAMA,GAAOC,EAAGL,GAAO,MAAM,IAAIM,UAAU,yIAA4I,IAA6CC,EAAzCC,GAAmB,EAAMC,GAAS,EAAY,MAAO,CAAER,EAAG,WAAelB,EAAKA,EAAGb,KAAKW,IAAOS,EAAG,WAAe,IAAIoB,EAAO3B,EAAG4B,OAAsC,OAA9BH,EAAmBE,EAAKR,KAAaQ,GAASvC,EAAG,SAAWyC,GAAOH,GAAS,EAAMF,EAAMK,GAAQP,EAAG,WAAe,IAAWG,GAAiC,MAAbzB,EAAG8B,QAAgB9B,EAAG8B,SAAY,QAAU,GAAIJ,EAAQ,MAAMF,KAIz9B,SAASlB,EAAkByB,EAAKC,IAAkB,MAAPA,GAAeA,EAAMD,EAAIhB,UAAQiB,EAAMD,EAAIhB,QAAQ,IAAK,IAAIC,EAAI,EAAGiB,EAAO,IAAI9B,MAAM6B,GAAMhB,EAAIgB,EAAKhB,IAAOiB,EAAKjB,GAAKe,EAAIf,GAAM,OAAOiB,EAEhL,SAASC,EAAQC,EAAQC,GAAkB,IAAIC,EAAO7B,OAAO6B,KAAKF,GAAS,GAAI3B,OAAO8B,sBAAuB,CAAE,IAAIC,EAAU/B,OAAO8B,sBAAsBH,GAAaC,IAAkBG,EAAUA,EAAQC,QAAO,SAAUC,GAAO,OAAOjC,OAAOkC,yBAAyBP,EAAQM,GAAKE,eAAkBN,EAAKO,KAAKhD,MAAMyC,EAAME,GAAY,OAAOF,EAElV,SAASQ,EAAcC,GAAU,IAAK,IAAI9B,EAAI,EAAGA,EAAIrB,UAAUoB,OAAQC,IAAK,CAAE,IAAI+B,EAAyB,MAAhBpD,UAAUqB,GAAarB,UAAUqB,GAAK,GAAQA,EAAI,EAAKkB,EAAQ1B,OAAOuC,IAAS,GAAMC,SAAQ,SAAUC,IAAO,OAAgBH,EAAQG,EAAKF,EAAOE,OAAsBzC,OAAO0C,0BAA6B1C,OAAO2C,iBAAiBL,EAAQtC,OAAO0C,0BAA0BH,IAAmBb,EAAQ1B,OAAOuC,IAASC,SAAQ,SAAUC,GAAOzC,OAAO4C,eAAeN,EAAQG,EAAKzC,OAAOkC,yBAAyBK,EAAQE,OAAe,OAAOH,EAI7gB,IAAIO,EAAU,SAAiBC,GAC7B,OAAOnD,MAAMC,QAAQkD,GAAOA,EAAMA,EAAM,CAACA,GAAO,IA6ClD,SAASC,EAAaC,GACpB,IAAIC,EAAIC,EAEJ/C,EAcJ,MAZI,UAAW6C,IACb7C,EAA0B,QAAlB8C,EAAKD,EAAEG,aAA0B,IAAPF,OAAgB,EAASA,EAAGrC,OAGpD,MAART,GAAgB,SAAU6C,IAC5B7C,EAAyB,QAAjB+C,EAAKF,EAAE7C,YAAyB,IAAP+C,OAAgB,EAASA,EAAGtC,OAGnD,MAART,IACFA,EAAO6C,EAAEI,MAGJjD,EAGT,SAASkD,EAAaL,EAAGM,EAAGC,GAC1B,IAAIC,EAAOT,EAAaC,GACpBS,EAAOV,EAAaO,GAExB,MAAwB,mBAAbC,EACFA,EAASC,EAAMC,GArC1B,SAAwBT,EAAGM,GACzB,OAAII,OAAOV,GAAKU,OAAOJ,IACb,EAGNI,OAAOV,GAAKU,OAAOJ,GACd,EAGF,EA+BAK,CAAeH,EAAMC,GAG9B,SAASG,EAAOC,GACd,OAAgB,MAATA,EAqBT,SAASC,EAAQlD,GACf,OAAOmD,EAAYnD,EAAO,IAG5B,SAASmD,EAAYnD,EAAOoD,GAC1B,cAAepD,GACb,IAAK,SACH,OAAOqD,KAAKC,UAAUtD,GAExB,IAAK,WACH,OAAOA,EAAMT,KAAO,aAAagE,OAAOvD,EAAMT,KAAM,KAAO,aAE7D,IAAK,SACH,OAON,SAA2BS,EAAOwD,GAChC,GAAc,OAAVxD,EACF,MAAO,OAGT,GAAIwD,EAAqBC,SAASzD,GAChC,MAAO,aAGT,IAAIoD,EAAa,GAAGG,QAAO,OAAmBC,GAAuB,CAACxD,IAEtE,GAaF,SAAoBA,GAClB,MAA+B,mBAAjBA,EAAM0D,OAdhBC,CAAW3D,GAAQ,CACrB,IAAI4D,EAAY5D,EAAM0D,SAEtB,GAAIE,IAAc5D,EAChB,MAA4B,iBAAd4D,EAAyBA,EAAYT,EAAYS,EAAWR,QAEvE,GAAIrE,MAAMC,QAAQgB,GACvB,OA+BJ,SAAqB6D,EAAOT,GAC1B,GAAqB,IAAjBS,EAAMlE,OACR,MAAO,KAGT,GAAIyD,EAAWzD,OA/ES,EAgFtB,MAAO,UAOT,IAJA,IAAIiB,EAAMkD,KAAKC,IApFM,GAoFgBF,EAAMlE,QACvCqE,EAAYH,EAAMlE,OAASiB,EAC3BqD,EAAQ,GAEHrE,EAAI,EAAGA,EAAIgB,IAAOhB,EACzBqE,EAAMzC,KAAK2B,EAAYU,EAAMjE,GAAIwD,IAGjB,IAAdY,EACFC,EAAMzC,KAAK,mBACFwC,EAAY,GACrBC,EAAMzC,KAAK,OAAO+B,OAAOS,EAAW,gBAGtC,MAAO,IAAMC,EAAMC,KAAK,MAAQ,IAtDvBC,CAAYnE,EAAOoD,GAG5B,OAOF,SAAsBrC,EAAQqC,GAC5B,IAAIgB,EAAUhF,OAAOgF,QAAQrD,GAE7B,GAAuB,IAAnBqD,EAAQzE,OACV,MAAO,KAGT,GAAIyD,EAAWzD,OA5DS,EA6DtB,MAAO,IAuCX,SAAsBoB,GACpB,IAAIsD,EAAMjF,OAAOvB,UAAUwB,SAAStB,KAAKgD,GAAQuD,QAAQ,aAAc,IAAIA,QAAQ,KAAM,IAEzF,GAAY,WAARD,GAAkD,mBAAvBtD,EAAOzC,YAA4B,CAChE,IAAIiB,EAAOwB,EAAOzC,YAAYiB,KAE9B,GAAoB,iBAATA,GAA8B,KAATA,EAC9B,OAAOA,EAIX,OAAO8E,EAlDQE,CAAaxD,GAAU,IAGtC,IAAIyD,EAAaJ,EAAQK,KAAI,SAAUC,GACrC,IAAIC,GAAQ,OAAeD,EAAM,GAIjC,OAHUC,EAAM,GAGH,KAAOxB,EAFRwB,EAAM,GAEqBvB,MAEzC,MAAO,KAAOoB,EAAWN,KAAK,MAAQ,KAzB/BU,CAAa5E,EAAOoD,GA5BhByB,CAAkB7E,EAAOoD,GAElC,QACE,OAAON,OAAO9C,IAyLpB,SAAS8E,EAA0BC,GACjC,IAAIC,EAA+BzG,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,GAAmBA,UAAU,GAAK,CAAC,cACxG,OAAOyG,EAA6BE,QAAO,SAAUC,EAAKC,GACxD,OAAc,MAAPD,EAAcA,EAAMA,EAAIC,KAC9BL,MAAAA,OAAmC,EAASA,EAAKM,YA2TtD,SAASC,EAAYC,GACnB,IAAI,QAAcA,GAAO,CACvB,IAAIC,EAAYF,EAAYC,EAAKE,QAEjC,GAAID,EAAUhD,OAAS,kBACrB,MAAM,IAAIkD,MAAM,qBAAqBnC,OAAOL,EAAQqC,GAAO,6DAG7D,MAAO,CACL/C,KAAM,kBACN+C,KAAMC,GAEH,OAAI,QAAWD,GACb,CACL/C,KAAM,cACN+C,KAAMD,EAAYC,EAAKE,SAIpB,CACLjD,KAAM,eACNjD,KAAM,CACJiD,KAAM,SACNxC,MAAOuF,EAAKhG,OAqBlB,SAASoG,EAAoB3F,GAE3B,GAAc,OAAVA,EACF,MAAO,CACLwC,KAAM,UAKV,QAAcyC,IAAVjF,EACF,OAAO,KAKT,GAAIjB,MAAMC,QAAQgB,GAAQ,CACxB,IAGI4F,EAHAC,EAAc,GAEdC,EAAarH,EAA2BuB,GAG5C,IACE,IAAK8F,EAAWhG,MAAO8F,EAASE,EAAW3G,KAAKY,MAAO,CACrD,IACIgG,EAAWJ,EADJC,EAAO5F,OAGF,MAAZ+F,GACFF,EAAYrE,KAAKuE,IAGrB,MAAO3F,GACP0F,EAAW9H,EAAEoC,GACb,QACA0F,EAAW5F,IAGb,MAAO,CACLsC,KAAM,SACNwD,OAAQH,GAIZ,GAAqB,iBAAV7F,EAAoB,CAC7B,IAAIiG,EAAa,GAEjB,IAAK,IAAIC,KAAalG,EAAO,CAC3B,IACImG,EAAMR,EADO3F,EAAMkG,IAGnBC,GACFF,EAAWzE,KAAK,CACdgB,KAAM,iBACNjD,KAAM,CACJiD,KAAM,SACNxC,MAAOkG,GAETlG,MAAOmG,IAKb,MAAO,CACL3D,KAAM,WACN4D,OAAQH,GAKZ,GAAqB,kBAAVjG,EACT,MAAO,CACLwC,KAAM,YACNxC,MAAOA,GAKX,GAAqB,iBAAVA,GAAsBqG,SAASrG,GAAQ,CAChD,IAAIsG,EAAYxD,OAAO9C,GACvB,OAAOuG,EAAoB9G,KAAK6G,GAAa,CAC3C9D,KAAM,QACNxC,MAAOsG,GACL,CACF9D,KAAM,UACNxC,MAAOsG,GAIX,GAAqB,iBAAVtG,EACT,MAAO,CACLwC,KAAM,WACNxC,MAAOA,GAIX,MAAM,IAAIG,UAAU,gCAAgCoD,OAAOvD,EAAO,MASpE,IAAIuG,EAAsB,wBAE1B,SAASC,EAASC,GAChB,IAAIC,EAAgB,IAAIC,QACxB,OAAO,SAAkBC,GACvB,IAAIC,EAAcH,EAAcI,IAAIF,GAEpC,QAAoB3B,IAAhB4B,EAA2B,CAC7B,IAAIE,EAAWN,EAAGG,GAElB,OADAF,EAAcM,IAAIJ,EAAIG,GACfA,EAGT,OAAOF,GAyOY,IAAIF,QAsCJH,GAAS,SAA0BS,GACxD,IAAIC,EAAYC,EAAaF,GAC7B,OAAO,IAAIG,KAAI,OAAmBF,GAAWzC,KAAI,SAAUc,GACzD,OAAOA,EAAKhG,YAHhB,IAMI4H,EAAeX,GAAS,SAAsBS,GAChD,IAAII,EAAcC,EAAeL,GACjC,OAAO,IAAIG,IAAIC,EAAYrB,aAEzBsB,EAAiBd,GAAS,SAAwBS,GACpD,IAAII,EAAc,IAAIE,IAClBC,EAAYP,EAAOQ,eAEnBD,GACFH,EAAYL,IAAI,QAASQ,GAG3B,IAAIE,EAAeT,EAAOU,kBAEtBD,GACFL,EAAYL,IAAI,WAAYU,GAG9B,IAAIE,EAAmBX,EAAOY,sBAM9B,OAJID,GACFP,EAAYL,IAAI,eAAgBY,GAG3BP,KAGT,SAASS,EAA0Bb,GACjC,IAQIc,EARAC,EAAUzJ,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,GAAmBA,UAAU,GAAK,GAC9EyG,EAA+BgD,EAAQhD,6BACvCiD,EAAWhB,EAAOiB,aAClBC,EAAaC,EAAcnB,EAAQjC,GACnCqD,EAA4B,MAAdF,EAAqB,CAACA,GAAc,GAClDG,EAAarB,EAAOsB,gBAEpBC,EAAc/J,EAA2B6J,GAG7C,IACE,IAAKE,EAAY1I,MAAOiI,EAAUS,EAAYrJ,KAAKY,MAAO,CACxD,IAAI0I,EAAYV,EAAQ/H,OAEpB,QAAqByI,IAIzBJ,EAAY7G,KAAKkH,EAAiBD,EAAWxB,EAAQjC,KAEvD,MAAO5E,GACPoI,EAAYxK,EAAEoC,GACd,QACAoI,EAAYtI,IAGd,IAAK,IAAIyI,KAAYV,EAAU,CAC7B,IAAI1C,EAAO0C,EAASU,GAChBC,GAAqB,QAAsBrD,GAC3CsD,GAAkB,QAAoBtD,GAE1C,IAAIqD,IAAsBC,EAI1B,IAAI,QAAatD,GACf8C,EAAY7G,KAAKsH,EAAkBvD,EAAM0B,EAAQjC,SAC5C,IAAI,QAAgBO,GACzB8C,EAAY7G,KAAKuH,EAAqBxD,EAAM0B,EAAQjC,SAC/C,IAAI,QAAYO,GACrB8C,EAAY7G,KAAKwH,EAAiBzD,EAAM0B,EAAQjC,SAC3C,IAAI,QAAkBO,GAC3B8C,EAAY7G,KAAKyH,EAAuB1D,EAAM0B,EAAQjC,SACjD,IAAI,QAAWO,GACpB8C,EAAY7G,KAAK0H,EAAgB3D,EAAM0B,EAAQjC,QAC1C,MAAI,QAAaO,GAGtB,MAAM,IAAIG,MAAM,gBAAgBnC,OAAOgC,EAAM,MAF7C8C,EAAY7G,KAAK2H,EAAkB5D,EAAM0B,EAAQjC,KAMrD,MAAO,CACLxC,KAAM,aACN6F,YAAaA,GAYjB,SAASD,EAAcnB,EAAQjC,GAC7B,IAAI3C,EAAIC,EAEJ8G,EAAmB,IAAI7B,IAAI,CAAC,CAAC,aAAStC,GAAY,CAAC,gBAAYA,GAAY,CAAC,oBAAgBA,KAC5FoE,EAAQ,GAMZ,GAJsB,MAAlBpC,EAAOqC,SACTD,EAAM7H,KAAKyF,EAAOqC,SAGY,MAA5BrC,EAAOsC,kBAA2B,CACpC,IACIC,EADAC,EAAchL,EAA2BwI,EAAOsC,mBAGpD,IACE,IAAKE,EAAY3J,MAAO0J,EAAUC,EAAYtK,KAAKY,MAAO,CACxD,IAAI2J,EAAmBF,EAAQxJ,MAC/BqJ,EAAM7H,KAAKkI,IAEb,MAAOtJ,GACPqJ,EAAYzL,EAAEoC,GACd,QACAqJ,EAAYvJ,KAIhB,IAAK,IAAIyJ,EAAM,EAAGC,EAASP,EAAOM,EAAMC,EAAOjK,OAAQgK,IAAO,CAC5D,IAAI5E,EAAO6E,EAAOD,GAElB,GAAI5E,EAAK8E,eAAgB,CACvB,IACIC,EADAC,EAActL,EAA2BsG,EAAK8E,gBAGlD,IACE,IAAKE,EAAYjK,MAAOgK,EAAUC,EAAY5K,KAAKY,MAAO,CACxD,IAAIiK,EAA8BF,EAAQ9J,MAC1CoJ,EAAiBpC,IAAIgD,EAA4BC,UAAWD,IAE9D,MAAO5J,GACP2J,EAAY/L,EAAEoC,GACd,QACA2J,EAAY7J,MAKlB,IAGIgK,EAHA7C,EAAcC,EAAeL,GAE7BkD,EAAc1L,EAA2B2K,GAG7C,IACE,IAAKe,EAAYrK,MAAOoK,EAAUC,EAAYhL,KAAKY,MAAO,CACxD,IAAIqK,GAAgB,OAAeF,EAAQlK,MAAO,GAC9CqK,EAAoBD,EAAc,GAClCE,EAA+BF,EAAc,GAE7CG,EAAWlD,EAAYP,IAAIuD,GAE/B,GAAgB,MAAZE,EAAkB,CACpB,IAAIC,EAAclF,EAAYiF,GAEM,MAAhCD,EACFA,EAA6B/E,KAAOiF,EAEpCpB,EAAiBpC,IAAIqD,EAAmB,CACtC7H,KAAM,8BACNyH,UAAWI,EACX9E,KAAMiF,MAKd,MAAOpK,GACP+J,EAAYnM,EAAEoC,GACd,QACA+J,EAAYjK,IAGd,IAAI2J,GAAiB,OAAmBT,EAAiBpD,UAAU5E,OAAO4B,GAEtEsF,EAAamC,EAAkBxD,EAAQA,EAAQjC,GAEnD,IAAK6E,EAAelK,SAAW2I,EAAW3I,OACxC,OAAO,KAGT,IAAIwI,EAAa,CACf3F,KAAwB,MAAlBqH,EAAyB,sBAAyB,qBACxDA,eAAgBA,EAEhBvB,WAAYA,GASd,OALAH,EAAWuC,aAAoG,QAApFpI,EAA+B,QAAzBD,EAAK4E,EAAOqC,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAA2B,MAAtB2E,EAAOyD,aAAuB,CACxKlI,KAAM,WACNxC,MAAOiH,EAAOyD,YACdC,OAAO,QACL1F,EACGkD,EAGT,SAASO,EAAiBD,EAAWxB,EAAQjC,GAC3C,IAAI3C,EAAIC,EAAIsI,EAAIC,EAEhB,MAAO,CACLrI,KAAM,yBACNkI,YAAqG,QAAvFpI,EAAkC,QAA5BD,EAAKoG,EAAUa,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAKmG,EAAUiC,YAAc,CACxJlI,KAAM,WACNxC,MAAOyI,EAAUiC,kBACfzF,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOyI,EAAUlJ,MAEnBhB,UAAqC,QAAzBqM,EAAKnC,EAAUqC,YAAyB,IAAPF,OAAgB,EAASA,EAAGnG,KAAI,SAAUsG,GACrF,OAAOC,EAAWD,EAAK9D,EAAQjC,MAEjCiG,WAAYxC,EAAUyC,aACtBC,WAA2C,QAA9BN,EAAKpC,EAAU0C,iBAA8B,IAAPN,OAAgB,EAASA,EAAGpG,KAAI,SAAU2G,GAC3F,MAAO,CACL5I,KAAM,SACNxC,MAAOoL,QAEJ,IAIX,SAASX,EAAkBY,EAAQpE,EAAQjC,GACzC,IAWIsD,EAXAgD,EAAyBxG,EAA0BuG,EAAQrG,GAC3DqE,EAAQ,GAYZ,GAVsB,MAAlBgC,EAAO/B,SACTD,EAAM7H,KAAK6J,EAAO/B,SAGhB,sBAAuB+B,GAAsC,MAA5BA,EAAO9B,oBAC1CF,EAAQA,EAAM9F,OAAO8H,EAAO9B,oBAKA,MAA1B+B,EACFhD,EAAaiD,GAAmBtE,EAAQqE,OACnC,CACLhD,EAAa,GAEb,IACIkD,EADAC,EAAchN,EAA2B4K,GAG7C,IACE,IAAKoC,EAAY3L,MAAO0L,EAAUC,EAAYtM,KAAKY,MAAO,CACxD,IAGM2L,EAHF3G,EAAOyG,EAAQxL,MAEnB,GAAI+E,EAAKuD,YAGNoD,EAAcpD,GAAY9G,KAAKhD,MAAMkN,GAAa,OAAmB3G,EAAKuD,cAG/E,MAAOlI,GACPqL,EAAYzN,EAAEoC,GACd,QACAqL,EAAYvL,KAIhB,OAAOoI,EAGT,SAASqD,EAA8BN,EAAQpE,EAAQjC,GACrD,IAAI3C,EAAIC,EAKJgG,EAHAsD,EAAkC,GAClCC,EAA0B,KAC1BP,EAAyBxG,EAA0BuG,EAAQrG,GAyB/D,OAhBkB,OALhBsD,EAD4B,MAA1BgD,EACWC,GAAmBtE,EAAQqE,GAED,QAAzBjJ,EAAKgJ,EAAO/B,eAA4B,IAAPjH,OAAgB,EAASA,EAAGiG,cAI3EsD,EAAkCtD,EAAWlH,QAAO,SAAUqH,GAC5D,MAAgC,eAAzBA,EAAUlJ,KAAKS,SAGQ,MAA5BqL,EAAOS,oBACTD,EAEQ,QAFmBvJ,EAAKgG,EAAWlH,QAAO,SAAUqH,GAC1D,MAAgC,eAAzBA,EAAUlJ,KAAKS,gBACD,IAAPsC,OAAgB,EAASA,EAAG,KAIhB,MAA5B+I,EAAOS,mBAAwD,MAA3BD,IACtCA,EAiPKE,GAAkB,aAAc,CACrCC,OAlPkDX,EAAOS,mBAmPxD,OAhP+B,MAA3BD,EAAkCD,EAAkC,CAACC,GAAyBtI,OAAOqI,GAG9G,SAASZ,EAAWD,EAAK9D,EAAQjC,GAC/B,IAAI3C,EAAIC,EAAIsI,EAEZ,MAAO,CACLpI,KAAM,2BACNkI,YAA+F,QAAjFpI,EAA4B,QAAtBD,EAAK0I,EAAIzB,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAKyI,EAAIL,YAAc,CAC5IlI,KAAM,WACNxC,MAAO+K,EAAIL,YACXC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAO+K,EAAIxL,MAEbgG,KAAMD,EAAYyF,EAAIxF,MAEtB0G,kBAAmChH,IAArB8F,EAAIkB,cAAiF,QAAnDrB,GAAK,OAAaG,EAAIkB,aAAclB,EAAIxF,aAA0B,IAAPqF,EAAgBA,OAAiB3F,EAC5IqD,WAAYqD,EAA8BZ,EAAK9D,EAAQjC,IAI3D,SAAS8D,EAAkBvD,EAAM0B,EAAQjC,GACvC,IAAI3C,EAAIC,EAER,MAAO,CACLE,KAAM,2BACNkI,YAAgG,QAAlFpI,EAA6B,QAAvBD,EAAKkD,EAAK+D,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAKiD,EAAKmF,YAAc,CAC9IlI,KAAM,WACNxC,MAAOuF,EAAKmF,YACZC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOuF,EAAKhG,MAEd6G,OAAQhH,OAAO4G,OAAOT,EAAK2G,aAAazH,KAAI,SAAU0H,GACpD,OAAOC,GAAaD,EAAOlF,EAAQjC,MAErCqH,WAAYjN,OAAO4G,OAAOT,EAAK+G,iBAAiB7H,KAAI,SAAU8H,GAC5D,OAAOjH,EAAYiH,MAErBjE,WAAYmC,EAAkBlF,EAAM0B,EAAQjC,IAIhD,SAAS+D,EAAqBxD,EAAM0B,EAAQjC,GAC1C,IAAI3C,EAAIC,EAEJyC,EAAO,CACTvC,KAAM,8BACNkI,YAAgG,QAAlFpI,EAA6B,QAAvBD,EAAKkD,EAAK+D,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAKiD,EAAKmF,YAAc,CAC9IlI,KAAM,WACNxC,MAAOuF,EAAKmF,YACZC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOuF,EAAKhG,MAEd6G,OAAQhH,OAAO4G,OAAOT,EAAK2G,aAAazH,KAAI,SAAU0H,GACpD,OAAOC,GAAaD,EAAOlF,EAAQjC,MAErCsD,WAAYmC,EAAkBlF,EAAM0B,EAAQjC,IAS9C,MANI,kBAAmBO,IACrBR,EAAKsH,WAAajN,OAAO4G,OAAOT,EAAK+G,iBAAiB7H,KAAI,SAAU8H,GAClE,OAAOjH,EAAYiH,OAIhBxH,EAGT,SAASiE,EAAiBzD,EAAM0B,EAAQjC,GACtC,IAAI3C,EAAIC,EAER,MAAO,CACLE,KAAM,0BACNkI,YAAgG,QAAlFpI,EAA6B,QAAvBD,EAAKkD,EAAK+D,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAKiD,EAAKmF,YAAc,CAC9IlI,KAAM,WACNxC,MAAOuF,EAAKmF,YACZC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOuF,EAAKhG,MAGd+I,WAAYmC,EAAkBlF,EAAM0B,EAAQjC,GAC5CwH,MAAOjH,EAAKkH,WAAWhI,KAAI,SAAUc,GACnC,OAAOD,EAAYC,OAKzB,SAAS0D,EAAuB1D,EAAM0B,EAAQjC,GAC5C,IAAI3C,EAAIC,EAER,MAAO,CACLE,KAAM,iCACNkI,YAAgG,QAAlFpI,EAA6B,QAAvBD,EAAKkD,EAAK+D,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAKiD,EAAKmF,YAAc,CAC9IlI,KAAM,WACNxC,MAAOuF,EAAKmF,YACZC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOuF,EAAKhG,MAEd6G,OAAQhH,OAAO4G,OAAOT,EAAK2G,aAAazH,KAAI,SAAU0H,GACpD,OAmFN,SAA2BA,EAAOlF,EAAQjC,GACxC,IAAI3C,EAAIC,EAAIsI,EAEZ,MAAO,CACLpI,KAAM,2BACNkI,YAAiG,QAAnFpI,EAA8B,QAAxBD,EAAK8J,EAAM7C,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAK6J,EAAMzB,YAAc,CAChJlI,KAAM,WACNxC,MAAOmM,EAAMzB,YACbC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOmM,EAAM5M,MAEfgG,KAAMD,EAAY6G,EAAM5G,MAExB+C,WAAYqD,EAA8BQ,EAAOlF,EAAQjC,GACzDiH,aAAsE,QAAvDrB,GAAK,OAAauB,EAAMF,aAAcE,EAAM5G,aAA0B,IAAPqF,EAAgBA,OAAK3F,GApG1FyH,CAAkBP,EAAOlF,EAAQjC,MAG1CsD,WAAYmC,EAAkBlF,EAAM0B,EAAQjC,IAIhD,SAASkE,EAAgB3D,EAAM0B,EAAQjC,GACrC,IAAI3C,EAAIC,EAER,MAAO,CACLE,KAAM,yBACNkI,YAAgG,QAAlFpI,EAA6B,QAAvBD,EAAKkD,EAAK+D,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAKiD,EAAKmF,YAAc,CAC9IlI,KAAM,WACNxC,MAAOuF,EAAKmF,YACZC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOuF,EAAKhG,MAEdyG,OAAQ5G,OAAO4G,OAAOT,EAAKoH,aAAalI,KAAI,SAAUzE,GACpD,OAkFN,SAA0BA,EAAOiH,EAAQjC,GACvC,IAAI3C,EAAIC,EAER,MAAO,CACLE,KAAM,0BACNkI,YAAiG,QAAnFpI,EAA8B,QAAxBD,EAAKrC,EAAMsJ,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAKtC,EAAM0K,YAAc,CAChJlI,KAAM,WACNxC,MAAOA,EAAM0K,YACbC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOA,EAAMT,MAGf+I,WAAYmC,EAAkBzK,EAAOiH,EAAQjC,IAjGpC4H,CAAiB5M,EAAOiH,EAAQjC,MAGzCsD,WAAYmC,EAAkBlF,EAAM0B,EAAQjC,IAIhD,SAASmE,EAAkB5D,EAAM0B,EAAQjC,GACvC,IAAI3C,EAAIC,EAAIsI,EAERU,EAAyBxG,EAA0BS,EAAMP,GACzDsD,EAAagD,EAAyBC,GAAmBtE,EAAQqE,IAAmD,QAAvBjJ,EAAKkD,EAAK+D,eAA4B,IAAPjH,OAAgB,EAASA,EAAGiG,aAAe,GAE3K,GAAI/C,EAAqB,iBAAM+C,EAAWuE,MAAK,SAAUC,GACvD,MAAoC,gBAA7BA,EAAcvN,KAAKS,SACxB,CACF,IAAI+M,EAAkB,CACpBC,IAAKzH,EAAqB,gBAE5B+C,EAAW9G,KAAKuK,GAAkB,cAAegB,IAGnD,MAAO,CACLvK,KAAM,2BACNkI,YAAgG,QAAlFE,EAA6B,QAAvBtI,EAAKiD,EAAK+D,eAA4B,IAAPhH,OAAgB,EAASA,EAAGoI,mBAAgC,IAAPE,EAAgBA,EAAKrF,EAAKmF,YAAc,CAC9IlI,KAAM,WACNxC,MAAOuF,EAAKmF,YACZC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOuF,EAAKhG,MAGd+I,WAAYA,GAIhB,SAAS8D,GAAaD,EAAOlF,EAAQjC,GACnC,IAAI3C,EAAIC,EAER,MAAO,CACLE,KAAM,qBACNkI,YAAiG,QAAnFpI,EAA8B,QAAxBD,EAAK8J,EAAM7C,eAA4B,IAAPjH,OAAgB,EAASA,EAAGqI,mBAAgC,IAAPpI,EAAgBA,EAAK6J,EAAMzB,YAAc,CAChJlI,KAAM,WACNxC,MAAOmM,EAAMzB,YACbC,OAAO,QACL1F,EACJ1F,KAAM,CACJiD,KAAM,SACNxC,MAAOmM,EAAM5M,MAEfhB,UAAW4N,EAAMrB,KAAKrG,KAAI,SAAUsG,GAClC,OAAOC,EAAWD,EAAK9D,EAAQjC,MAEjCO,KAAMD,EAAY6G,EAAM5G,MAExB+C,WAAYqD,EAA8BQ,EAAOlF,EAAQjC,IAkD7D,SAAS+G,GAAkBxM,EAAMuL,EAAMrC,GACrC,IAAIwE,EAAqB,GAEzB,GAAiB,MAAbxE,EAAmB,CACrB,IACIyE,EADAC,EAAc1O,EAA2BgK,EAAUqC,MAGvD,IACE,IAAKqC,EAAYrN,MAAOoN,EAAUC,EAAYhO,KAAKY,MAAO,CACxD,IAAIgL,EAAMmC,EAAQlN,MACdoN,EAAUrC,EAAIxL,KACd8N,EAAWvC,EAAKsC,GAEpB,QAAiBnI,IAAboI,EAAwB,CAC1B,IAAIrN,GAAQ,OAAaqN,EAAUtC,EAAIxF,MAEnCvF,GACFiN,EAAmBzL,KAAK,CACtBgB,KAAM,aACNjD,KAAM,CACJiD,KAAM,SACNxC,MAAOoN,GAETpN,MAAOA,MAKf,MAAOI,GACP+M,EAAYnP,EAAEoC,GACd,QACA+M,EAAYjN,UAGd,IAAK,IAAIoN,KAAYxC,EAAM,CACzB,IAEIyC,EAAS5H,EAFGmF,EAAKwC,IAIjBC,GACFN,EAAmBzL,KAAK,CACtBgB,KAAM,aACNjD,KAAM,CACJiD,KAAM,SACNxC,MAAOsN,GAETtN,MAAOuN,IAMf,MAAO,CACL/K,KAAM,cACNjD,KAAM,CACJiD,KAAM,SACNxC,MAAOT,GAEThB,UAAW0O,GAIf,SAAS1B,GAAmBtE,EAAQuG,GAClC,IAAIC,EAAiB,GAErB,IAAK,IAAIC,KAAiBF,EAAiB,CACzC,IAAIG,EAAqBH,EAAgBE,GACrCjF,EAAYxB,MAAAA,OAAuC,EAASA,EAAO2G,aAAaF,GAEpF,GAAI3O,MAAMC,QAAQ2O,GAAqB,CACrC,IACIE,EADAC,EAAcrP,EAA2BkP,GAG7C,IACE,IAAKG,EAAYhO,MAAO+N,EAAUC,EAAY3O,KAAKY,MAAO,CACxD,IAAIC,EAAQ6N,EAAQ7N,MACpByN,EAAejM,KAAKuK,GAAkB2B,EAAe1N,EAAOyI,KAE9D,MAAOrI,GACP0N,EAAY9P,EAAEoC,GACd,QACA0N,EAAY5N,UAGduN,EAAejM,KAAKuK,GAAkB2B,EAAeC,EAAoBlF,IAI7E,OAAOgF,EAGT,IAAIM,GAAqBC,WAAWC,eAEpC,QAAkC,IAAvBF,GAAoC,CAC7C,IAAIG,GAAmC,SAAUC,IAC/C,OAAUD,EAAqBC,GAE/B,IAAIC,EAAS/Q,EAAa6Q,GAE1B,SAASA,EAAoBG,GAC3B,IAAIC,EAEAC,EAAUhQ,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,GAAmBA,UAAU,GAAK,GAQlF,OANA,OAAgBF,KAAM6P,IAEtBI,EAAQF,EAAOrQ,KAAKM,KAAMkQ,IACpBF,OAASA,EACfC,EAAM/O,KAAO,iBACbmG,MAAM8I,mBAAkB,OAAuBF,GAAQJ,GAChDI,EAGT,OAAOJ,EAnB8B,EAoBvB,OAAiBxI,QAEjCqI,GAAqB,SAA4BM,EAAQE,GACvD,OAAO,IAAIL,GAAoBG,EAAQE,IA6O3C,IACIE,GAAmB,GAEvB,SAASC,KACPD,GAAmB,GAGrB,SAASE,GAAe5J,GACtB,IAAI1C,EAEAuM,EAAkC,QAApBvM,EAAK0C,EAAKxF,YAAyB,IAAP8C,OAAgB,EAASA,EAAGrC,MAE1E,GAAkB,MAAd4O,EAMJ,OAFAC,GAAY9J,EAAM6J,GAEV7J,EAAKvC,MACX,IAAK,qBACH,GAAIuC,EAAKiB,OAAQ,CACf,IACI8I,EADAC,EAActQ,EAA2BsG,EAAKiB,QAGlD,IACE,IAAK+I,EAAYjP,MAAOgP,EAAUC,EAAY5P,KAAKY,MAAO,CACxD,IAAIC,EAAQ8O,EAAQ9O,MACpB6O,GAAY7O,EAAO4O,EAAY5O,EAAMT,KAAKS,QAE5C,MAAOI,GACP2O,EAAY/Q,EAAEoC,GACd,QACA2O,EAAY7O,KAIhB,MAEF,IAAK,uBACL,IAAK,4BACL,IAAK,0BACH,GAAI6E,EAAKqB,OAAQ,CACf,IACI4I,EADAC,EAAcxQ,EAA2BsG,EAAKqB,QAGlD,IACE,IAAK6I,EAAYnP,MAAOkP,EAAUC,EAAY9P,KAAKY,MAAO,CACxD,IAAIoM,EAAQ6C,EAAQhP,MAGpB,GAFA6O,GAAY1C,EAAOyC,EAAYzC,EAAM5M,KAAKS,OAEtCkP,GAAsB/C,IAAUA,EAAM5N,UAAW,CACnD,IACI4Q,EADAC,EAAc3Q,EAA2B0N,EAAM5N,WAGnD,IACE,IAAK6Q,EAAYtP,MAAOqP,EAAUC,EAAYjQ,KAAKY,MAAO,CACxD,IAAIgL,EAAMoE,EAAQnP,MAClB6O,GAAY9D,EAAK6D,EAAYzC,EAAM5M,KAAKS,MAAO+K,EAAIxL,KAAKS,QAE1D,MAAOI,GACPgP,EAAYpR,EAAEoC,GACd,QACAgP,EAAYlP,OAIlB,MAAOE,GACP6O,EAAYjR,EAAEoC,GACd,QACA6O,EAAY/O,OAQtB,SAAS2O,GAAY9J,EAAMsG,EAAQc,EAAOkD,GACxC,IAAIC,EAAUC,GAAWxK,GAEzB,GAAuB,iBAAZuK,GAA2C,IAAnBA,EAAQ3P,OAA3C,CAIA,IAAIsB,EAAO,CAACoK,GAERc,IACFlL,EAAKO,KAAK2K,GAENkD,GACFpO,EAAKO,KAAK6N,IAId,IAAIG,EAAOvO,EAAKiD,KAAK,KAEhBuK,GAAiBe,KACpBf,GAAiBe,GAAQ,IAG3Bf,GAAiBe,GAAMhO,KAAK8N,IAG9B,SAASG,GAAaH,GACpB,MAAO,OAASA,EAAQhL,QAAQ,MAAO,QAoBzC,SAASJ,GAAKwL,EAAYC,GACxB,OAAOD,EAAaA,EAAWtO,QAAO,SAAUwO,GAC9C,OAAOA,KACN1L,KAAKyL,GAAa,IAAM,GAG7B,SAASE,GAAkBH,GACzB,IAAIrN,EAEJ,OAEQ,QAFAA,EAAKqN,MAAAA,OAA+C,EAASA,EAAW7C,MAAK,SAAUiD,GAC7F,OAAOA,EAAIrM,SAAS,gBACC,IAAPpB,GAAgBA,EA0BlC,SAAS0N,GAAOC,GACd,OAAOA,GAAe,KAAKzM,OAAOyM,EAAY1L,QAAQ,MAAO,SAQ/D,SAASqG,GAAM9G,GACb,OAAOA,GAA0B,IAAjBA,EAAMlE,OAAe,MAAM4D,OAAOwM,GAAO7L,GAAKL,EAAO,OAAQ,OAAS,GAQxF,SAASoM,GAAKC,EAAOF,EAAaG,GAChC,OAAOH,EAAcE,EAAQF,GAAeG,GAAO,IAAM,GAe3D,IAAIC,GAAqB,CACvBC,KAAM,CACJC,MAAO,SAAevL,GACpB,OAAOA,EAAK/E,QAGhBuQ,SAAU,CACRD,MAAO,SAAevL,GACpB,MAAO,IAAMA,EAAKxF,OAItBiR,SAAU,CACRF,MAAO,SAAevL,GACpB,OAAOb,GAAKa,EAAKsD,YAAa,UAGlCoI,oBAAqB,CACnBH,MAAO,SAAevL,GACpB,IAAI2L,EAAUT,GAAK,IAAK/L,GAAKa,EAAK4L,oBAAqB,MAAO,KAG9D,OAFazM,GAAK,CAACa,EAAKkF,UAAW/F,GAAK,CAACa,EAAKxF,KAAMmR,IAAWxM,GAAKa,EAAKuD,WAAY,MAAO,KAE5E,IAAMvD,EAAK6L,eAG/BC,mBAAoB,CAClBP,MAAO,SAAeQ,GACpB,IAAIC,EAAWD,EAAMC,SACjBxL,EAAOuL,EAAMvL,KACb0G,EAAe6E,EAAM7E,aACrB3D,EAAawI,EAAMxI,WACvB,OAAOyI,EAAW,KAAOxL,EAAO0K,GAAK,MAAOhE,GAAgBgE,GAAK,IAAK/L,GAAKoE,EAAY,QAG3F0I,aAAc,CACZV,MAAO,SAAeW,GAEpB,OAAOtG,GADUsG,EAAMC,cAI3BC,MAAO,CACLb,MAAO,SAAec,GACpB,IAAI7O,EAAQ6O,EAAM7O,MACdhD,EAAO6R,EAAM7R,KACbuL,EAAOsG,EAAM7S,UACb+J,EAAa8I,EAAM9I,WACnBsI,EAAeQ,EAAMR,aACrBS,EAASpB,GAAK,GAAI1N,EAAO,MAAQhD,EACjC+R,EAAWD,EAASpB,GAAK,IAAK/L,GAAK4G,EAAM,MAAO,KAMpD,OAJIwG,EAAS3R,OArPG,KAsPd2R,EAAWD,EAASpB,GAAK,MAAOF,GAAO7L,GAAK4G,EAAM,OAAQ,QAGrD5G,GAAK,CAACoN,EAAUpN,GAAKoE,EAAY,KAAMsI,GAAe,OAGjEW,SAAU,CACRjB,MAAO,SAAekB,GAGpB,OAFWA,EAAMjS,KAEH,KADFiS,EAAMxR,QAKtByR,eAAgB,CACdnB,MAAO,SAAeoB,GAGpB,MAAO,MAFIA,EAAMnS,KAEK0Q,GAAK,IAAK/L,GADfwN,EAAMpJ,WAC0B,QAGrDqJ,eAAgB,CACdrB,MAAO,SAAesB,GACpB,IAAIC,EAAgBD,EAAOC,cACvBvJ,EAAasJ,EAAOtJ,WACpBsI,EAAegB,EAAOhB,aAC1B,OAAO1M,GAAK,CAAC,MAAO+L,GAAK,MAAO4B,GAAgB3N,GAAKoE,EAAY,KAAMsI,GAAe,OAG1FkB,mBAAoB,CAClBxB,MAAO,SAAeyB,GACpB,IAAIxS,EAAOwS,EAAOxS,KACdsS,EAAgBE,EAAOF,cACvBlB,EAAsBoB,EAAOpB,oBAC7BrI,EAAayJ,EAAOzJ,WACpBsI,EAAemB,EAAOnB,aAC1B,MAEE,YAAYrN,OAAOhE,GAAMgE,OAAO0M,GAAK,IAAK/L,GAAKyM,EAAqB,MAAO,KAAM,KAAO,MAAMpN,OAAOsO,EAAe,KAAKtO,OAAO0M,GAAK,GAAI/L,GAAKoE,EAAY,KAAM,MAAQsI,IAK9KoB,SAAU,CACR1B,MAAO,SAAe2B,GAEpB,OADYA,EAAOjS,QAIvBkS,WAAY,CACV5B,MAAO,SAAe6B,GAEpB,OADYA,EAAOnS,QAIvBoS,YAAa,CACX9B,MAAO,SAAe+B,GACpB,IAAIrS,EAAQqS,EAAOrS,MAGnB,OAFoBqS,EAAO1H,MAnHjC,SAA0B3K,GACxB,IAAIsS,EAAgB/T,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,IAAmBA,UAAU,GAC/EgU,EAAUvS,EAAMsE,QAAQ,OAAQ,SACpC,MAAqB,MAAbtE,EAAM,IAA2B,OAAbA,EAAM,KAAyC,IAAzBA,EAAMwS,QAAQ,MAAyE,QAAWjP,OAAO+O,EAAgBC,EAAUxC,GAAOwC,GAAU,SAAvH,MAAShP,OAAOgP,EAAQjO,QAAQ,KAAM,OAAQ,OAmHhHmO,CAAiBzS,GAGnBqD,KAAKC,UAAUtD,KAG1B0S,aAAc,CACZpC,MAAO,SAAeqC,GAEpB,OADYA,EAAO3S,MACJ,OAAS,UAG5B4S,UAAW,CACTtC,MAAO,WACL,MAAO,SAGXuC,UAAW,CACTvC,MAAO,SAAewC,GAEpB,OADYA,EAAO9S,QAIvB+S,UAAW,CACTzC,MAAO,SAAe0C,GAEpB,MAAO,IAAM9O,GADA8O,EAAOhN,OACM,MAAQ,MAGtCiN,YAAa,CACX3C,MAAO,SAAe4C,GAEpB,MAAO,IAAMhP,GADAgP,EAAO9M,OACM,MAAQ,MAGtC+M,YAAa,CACX7C,MAAO,SAAe8C,GAGpB,OAFWA,EAAO7T,KAEJ,KADF6T,EAAOpT,QAKvBqT,UAAW,CACT/C,MAAO,SAAegD,GAGpB,MAAO,IAFIA,EAAO/T,KAEE0Q,GAAK,IAAK/L,GADnBoP,EAAO/U,UACuB,MAAO,OAIpDgV,UAAW,CACTjD,MAAO,SAAekD,GAEpB,OADWA,EAAOjU,OAItBkU,SAAU,CACRnD,MAAO,SAAeoD,GAEpB,MAAO,IADIA,EAAOnO,KACE,MAGxBoO,YAAa,CACXrD,MAAO,SAAesD,GAEpB,OADWA,EAAOrO,KACJ,MAIlBsO,iBAAkB,CAChBvD,MAAO,SAAewD,GACpB,IAAIxL,EAAawL,EAAOxL,WACpBuB,EAAiBiK,EAAOjK,eAC5B,OAAO3F,GAAK,CAAC,SAAUA,GAAKoE,EAAY,KAAMqC,GAAMd,IAAkB,OAG1EkK,wBAAyB,CACvBzD,MAAO,SAAe0D,GAGpB,OAFgBA,EAAO/J,UAEJ,KADR+J,EAAOzO,OAItB0O,qBAAsB,CACpB3D,MAAO,SAAe4D,GAGpB,OAAOhQ,GAAK,CAAC,SAFFgQ,EAAO3U,KAEW2E,GADZgQ,EAAO5L,WACsB,MAAO,OAGzD6L,qBAAsB,CACpB7D,MAAO,SAAe8D,GACpB,IAAI7U,EAAO6U,EAAO7U,KACd8M,EAAa+H,EAAO/H,WACpB/D,EAAa8L,EAAO9L,WACpBlC,EAASgO,EAAOhO,OACpB,OAAOlC,GAAK,CAAC,OAAQ3E,EAAM0Q,GAAK,cAAe/L,GAAKmI,EAAY,QAASnI,GAAKoE,EAAY,KAAMqC,GAAMvE,IAAU,OAGpHiO,gBAAiB,CACf/D,MAAO,SAAegE,GACpB,IAAI/U,EAAO+U,EAAO/U,KACduL,EAAOwJ,EAAO/V,UACdgH,EAAO+O,EAAO/O,KACd+C,EAAagM,EAAOhM,WACxB,OAAO/I,GAAQsQ,GAAkB/E,GAAQmF,GAAK,MAAOF,GAAO7L,GAAK4G,EAAM,OAAQ,OAASmF,GAAK,IAAK/L,GAAK4G,EAAM,MAAO,MAAQ,KAAOvF,EAAO0K,GAAK,IAAK/L,GAAKoE,EAAY,QAGzKiM,qBAAsB,CACpBjE,MAAO,SAAekE,GACpB,IAAIjV,EAAOiV,EAAOjV,KACdgG,EAAOiP,EAAOjP,KACd0G,EAAeuI,EAAOvI,aACtB3D,EAAakM,EAAOlM,WACxB,OAAOpE,GAAK,CAAC3E,EAAO,KAAOgG,EAAM0K,GAAK,KAAMhE,GAAe/H,GAAKoE,EAAY,MAAO,OAGvFmM,wBAAyB,CACvBnE,MAAO,SAAeoE,GACpB,IAAInV,EAAOmV,EAAOnV,KACd8M,EAAaqI,EAAOrI,WACpB/D,EAAaoM,EAAOpM,WACpBlC,EAASsO,EAAOtO,OACpB,OAAOlC,GAAK,CAAC,YAAa3E,EAAM0Q,GAAK,cAAe/L,GAAKmI,EAAY,QAASnI,GAAKoE,EAAY,KAAMqC,GAAMvE,IAAU,OAGzHuO,oBAAqB,CACnBrE,MAAO,SAAesE,GACpB,IAAIrV,EAAOqV,EAAOrV,KACd+I,EAAasM,EAAOtM,WACpBkE,EAAQoI,EAAOpI,MACnB,OAAOtI,GAAK,CAAC,QAAS3E,EAAM2E,GAAKoE,EAAY,KAAM2H,GAAK,KAAM/L,GAAKsI,EAAO,SAAU,OAGxFqI,mBAAoB,CAClBvE,MAAO,SAAewE,GACpB,IAAIvV,EAAOuV,EAAOvV,KACd+I,EAAawM,EAAOxM,WACpBtC,EAAS8O,EAAO9O,OACpB,OAAO9B,GAAK,CAAC,OAAQ3E,EAAM2E,GAAKoE,EAAY,KAAMqC,GAAM3E,IAAU,OAGtE+O,oBAAqB,CACnBzE,MAAO,SAAe0E,GAGpB,OAAO9Q,GAAK,CAFD8Q,EAAOzV,KAEC2E,GADF8Q,EAAO1M,WACY,MAAO,OAG/C2M,0BAA2B,CACzB3E,MAAO,SAAe4E,GACpB,IAAI3V,EAAO2V,EAAO3V,KACd+I,EAAa4M,EAAO5M,WACpBlC,EAAS8O,EAAO9O,OACpB,OAAOlC,GAAK,CAAC,QAAS3E,EAAM2E,GAAKoE,EAAY,KAAMqC,GAAMvE,IAAU,OAGvE+O,oBAAqB,CACnB7E,MAAO,SAAe8E,GACpB,IAAI7V,EAAO6V,EAAO7V,KACduL,EAAOsK,EAAO7W,UACd0M,EAAamK,EAAOnK,WACpBE,EAAYiK,EAAOjK,UACvB,MAAO,cAAgB5L,GAAQsQ,GAAkB/E,GAAQmF,GAAK,MAAOF,GAAO7L,GAAK4G,EAAM,OAAQ,OAASmF,GAAK,IAAK/L,GAAK4G,EAAM,MAAO,OAASG,EAAa,cAAgB,IAAM,OAAS/G,GAAKiH,EAAW,SAG7MkK,gBAAiB,CACf/E,MAAO,SAAegF,GACpB,IAAIhN,EAAagN,EAAOhN,WACpBuB,EAAiByL,EAAOzL,eAC5B,OAAO3F,GAAK,CAAC,gBAAiBA,GAAKoE,EAAY,KAAMqC,GAAMd,IAAkB,OAGjF0L,oBAAqB,CACnBjF,MAAO,SAAekF,GAGpB,OAAOtR,GAAK,CAAC,gBAFFsR,EAAOjW,KAEkB2E,GADnBsR,EAAOlN,WAC6B,MAAO,OAGhEmN,oBAAqB,CACnBnF,MAAO,SAAeoF,GACpB,IAAInW,EAAOmW,EAAOnW,KACd8M,EAAaqJ,EAAOrJ,WACpB/D,EAAaoN,EAAOpN,WACpBlC,EAASsP,EAAOtP,OACpB,OAAOlC,GAAK,CAAC,cAAe3E,EAAM0Q,GAAK,cAAe/L,GAAKmI,EAAY,QAASnI,GAAKoE,EAAY,KAAMqC,GAAMvE,IAAU,OAG3HuP,uBAAwB,CACtBrF,MAAO,SAAesF,GACpB,IAAIrW,EAAOqW,EAAOrW,KACd8M,EAAauJ,EAAOvJ,WACpB/D,EAAasN,EAAOtN,WACpBlC,EAASwP,EAAOxP,OACpB,OAAOlC,GAAK,CAAC,mBAAoB3E,EAAM0Q,GAAK,cAAe/L,GAAKmI,EAAY,QAASnI,GAAKoE,EAAY,KAAMqC,GAAMvE,IAAU,OAGhIyP,mBAAoB,CAClBvF,MAAO,SAAewF,GACpB,IAAIvW,EAAOuW,EAAOvW,KACd+I,EAAawN,EAAOxN,WACpBkE,EAAQsJ,EAAOtJ,MACnB,OAAOtI,GAAK,CAAC,eAAgB3E,EAAM2E,GAAKoE,EAAY,KAAM2H,GAAK,KAAM/L,GAAKsI,EAAO,SAAU,OAG/FuJ,kBAAmB,CACjBzF,MAAO,SAAe0F,GACpB,IAAIzW,EAAOyW,EAAOzW,KACd+I,EAAa0N,EAAO1N,WACpBtC,EAASgQ,EAAOhQ,OACpB,OAAO9B,GAAK,CAAC,cAAe3E,EAAM2E,GAAKoE,EAAY,KAAMqC,GAAM3E,IAAU,OAG7EiQ,yBAA0B,CACxB3F,MAAO,SAAe4F,GACpB,IAAI3W,EAAO2W,EAAO3W,KACd+I,EAAa4N,EAAO5N,WACpBlC,EAAS8P,EAAO9P,OACpB,OAAOlC,GAAK,CAAC,eAAgB3E,EAAM2E,GAAKoE,EAAY,KAAMqC,GAAMvE,IAAU,QAI5E+P,GAAiC/W,OAAO6B,KAAKmP,IAAoBlL,QAAO,SAAUkR,EAAMvU,GAC1F,OAAOJ,EAAcA,EAAc,GAAI2U,GAAO,IAAI,OAAgB,GAAIvU,EAAK,CACzEyO,OA3YoB+F,EA2YEjG,GAAmBvO,GAAKyO,MA1YzC,SAAUvL,EAAMuR,EAAMC,EAAS/G,EAAMgH,GAC1C,IAAInU,EAEApB,EAAO,GACPwV,EAASjH,EAAKtK,QAAO,SAAUkR,EAAMvU,GAKvC,MAJI,CAAC,SAAU,YAAa,UAAU4B,SAAS5B,IAAQuU,EAAK7W,MAC1D0B,EAAKO,KAAK4U,EAAK7W,KAAKS,OAGfoW,EAAKvU,KACX2U,EAAU,IACT3U,EAAM,GAAG0B,OAAOtC,EAAM,CAAwE,QAAtEoB,EAAKoU,MAAAA,OAAuC,EAASA,EAAOlX,YAAyB,IAAP8C,OAAgB,EAASA,EAAGrC,QAAQoB,OAAOxD,SAASsG,KAAK,KAC/JD,EAAQ,GAMZ,OAJIc,EAAKvC,KAAKiB,SAAS,eAAiBgL,GAAiB5M,IACvDoC,EAAMzC,KAAKhD,MAAMyF,GAAO,OAAmBwK,GAAiB5M,KAGvDqC,GAAK,GAAGX,QAAO,OAAmBU,EAAMQ,IAAIgL,KAAgB,CAAC1K,EAAK2F,YAAa2L,EAAGtR,EAAMuR,EAAMC,EAAS/G,EAAMgH,KAAc,WAnBtI,IAAwBH,IA6YrB,IAMH,SAASK,GAAkBvQ,GACzB,OAAO,QAAMA,EAAKgQ,IAGpB,SAASjH,GAAsBnK,GAC7B,MAAqB,oBAAdA,EAAKvC,KAcd,SAAS+M,GAAWxK,GAClB,IAAI4R,EAAWC,GAAuB7R,GAEtC,QAAiBE,IAAb0R,EACF,OAAOE,GAAuB,KAAKtT,OAAOoT,IAI9C,SAASC,GAAuB7R,GAC9B,IAAI+R,EAAM/R,EAAK+R,IAEf,GAAKA,EAAL,CAOA,IAHA,IAAIC,EAAW,GACXC,EAAQF,EAAIG,WAAWb,KAEX,MAATY,GAAiBA,EAAMxU,OAAS,EAAA0U,EAAA,SAAmC,MAAdF,EAAMxW,MAA8B,MAAdwW,EAAMZ,MAAgBY,EAAMG,KAAO,IAAMH,EAAMxW,KAAK2W,MAAQH,EAAMG,OAASH,EAAMZ,KAAKe,MAAM,CAC5K,IAAInX,EAAQ8C,OAAOkU,EAAMhX,OACzB+W,EAASvV,KAAKxB,GACdgX,EAAQA,EAAMZ,KAGhB,OAAOW,EAASpX,OAAS,EAAIoX,EAASK,UAAUlT,KAAK,WAAQe,GAG/D,SAAS4R,GAAuBQ,GAE9B,IAAIC,EAAQD,EAAUE,MAAM,gBAExBC,EAyBN,SAAmCF,GAGjC,IAFA,IAAIE,EAAe,KAEV5X,EAAI,EAAGA,EAAI0X,EAAM3X,OAAQC,IAAK,CACrC,IAAIuX,EAAOG,EAAM1X,GAEb6X,EAAUC,GAAkBP,GAEhC,GAAIM,IAAYN,EAAKxX,UAIA,OAAjB6X,GAAyBC,EAAUD,IAGhB,KAFrBA,EAAeC,IAGb,MAKN,OAAwB,OAAjBD,EAAwB,EAAIA,EA9ChBG,CAA0BL,GAE7C,GAAqB,IAAjBE,EACF,IAAK,IAAI5X,EAAI,EAAGA,EAAI0X,EAAM3X,OAAQC,IAChC0X,EAAM1X,GAAK0X,EAAM1X,GAAGN,MAAMkY,GAK9B,KAAOF,EAAM3X,OAAS,GAAKiY,GAAQN,EAAM,KACvCA,EAAMO,QAGR,KAAOP,EAAM3X,OAAS,GAAKiY,GAAQN,EAAMA,EAAM3X,OAAS,KACtD2X,EAAMQ,MAIR,OAAOR,EAAMpT,KAAK,MA+BpB,SAASwT,GAAkB5H,GAGzB,IAFA,IAAIlQ,EAAI,EAEDA,EAAIkQ,EAAInQ,SAAsB,MAAXmQ,EAAIlQ,IAAyB,OAAXkQ,EAAIlQ,KAC9CA,IAGF,OAAOA,EAGT,SAASgY,GAAQ9H,GACf,OAAO4H,GAAkB5H,KAASA,EAAInQ,OA6ExC,IAwcIoY,GAvce,IAAIxQ,IAqevB,SAASyQ,GAAyBC,EAAS1S,GACzC,GAAIA,EAAM,CACR,IAAI2S,EAAkBD,EAAQ1S,EAAKhG,MAEnC,IAAI,QAAa2Y,GACf,OAAOA,GA8Eb,SAASC,GAAYC,EAAiB9P,GACpC,IAAI+P,EAAmBjZ,OAAOkZ,OAAO,MAErC,IAAK,IAAI3P,KAAYyP,EACnBC,EAAiB1P,GAAYyP,EAAgBzP,GAG/C,IAAI4P,EAAanZ,OAAOkZ,OAAO,MAE/B,IAAK,IAAIE,KAAaH,EAAkB,CACtC,IAAII,EAAYJ,EAAiBG,GAEjC,GAAiB,MAAbC,IAAqBD,EAAUE,WAAW,MAA9C,CAIA,IAAIC,EAAUF,EAAUlZ,KAExB,IAAIoZ,EAAQD,WAAW,MAAvB,CAIA,GAA2B,MAAvBH,EAAWI,GACb,MAAM,IAAIjT,MAAM,8BAA8BnC,OAAOoV,IAGvDJ,EAAWI,GAAWF,IAGxB,IAAK,IAAIG,KAAcL,EACrBA,EAAWK,GAAcC,EAAgBN,EAAWK,IAGtD,IAAIE,EAAgBxQ,EAAW7D,KAAI,SAAUgE,GAC3C,OAOF,SAAyBA,GACvB,IAAI,QAAqBA,GACvB,OAAOA,EAGT,IAAIsQ,EAAkBtQ,EAAUuQ,WAEhC,OADAD,EAAgBjO,KAAOmO,EAAWF,EAAgBjO,MAC3C,IAAI,KAAiBiO,GAdrBG,CAAgBzQ,MAEzB,MAAO,CACLwP,QAASM,EACTjQ,WAAYwQ,GAad,SAASG,EAAWnO,GAClB,IAAIqO,EAAc,GAElB,IAAK,IAAI/L,KAAWtC,EAAM,CACxB,IAAIC,EAAMD,EAAKsC,GACXgM,EAAiBC,EAAWtO,EAAIxF,MAEd,MAAlB6T,IACFrO,EAAIxF,KAAO6T,EACXD,EAAY/L,GAAWrC,GAI3B,OAAOoO,EAGT,SAASN,EAAgBtT,GACvB,IAAI,QAAaA,GAAO,CACtB,IAAI+T,EAAS/T,EAAKyT,WAEdO,EAAY9X,EAAcA,EAAc,GAAI6X,GAAS,GAAI,CAC3DlT,OAAQ,WACN,OAAOoT,EAAaF,EAAOlT,SAE7BiG,WAAY,WACV,OAAOoN,EAAiBH,EAAOjN,eAInC,OAAO,IAAI,KAAkBkN,GACxB,IAAI,QAAgBhU,GAAO,CAChC,IAAImU,EAAUnU,EAAKyT,WAEfW,EAAalY,EAAcA,EAAc,GAAIiY,GAAU,GAAI,CAC7DtT,OAAQ,WACN,OAAOoT,EAAaE,EAAQtT,WAUhC,MANI,eAAgBuT,IAClBA,EAAWtN,WAAa,WACtB,OAAOoN,EAAiBC,EAAQrN,cAI7B,IAAI,KAAqBsN,GAC3B,IAAI,QAAYpU,GAAO,CAC5B,IAAIqU,EAAWrU,EAAKyT,WAEhBa,EAAcpY,EAAcA,EAAc,GAAImY,GAAW,GAAI,CAC/DpN,MAAO,WACL,OAAOiN,EAAiBG,EAASpN,UAIrC,OAAO,IAAI,KAAiBqN,GACvB,IAAI,QAAkBtU,GAAO,CAClC,IAAIuU,EAAWvU,EAAKyT,WAEhBe,EAActY,EAAcA,EAAc,GAAIqY,GAAW,GAAI,CAC/D1T,OAAQ,WACN,OAqCR,SAA2BA,GACzB,IAAI4T,EAAgB,GAEpB,IAAK,IAAI9T,KAAaE,EAAQ,CAC5B,IAAI+F,EAAQ/F,EAAOF,GACf+T,EAAmBZ,EAAWlN,EAAM5G,MAEhB,MAApB0U,IACF9N,EAAM5G,KAAO0U,EACbD,EAAc9T,GAAaiG,GAI/B,OAAO6N,EAlDME,CAAkBJ,EAAS1T,WAItC,OAAO,IAAI,KAAuB2T,GAC7B,IAAI,QAAWxU,GAAO,CAC3B,IAAI4U,EAAa5U,EAAKyT,WACtB,OAAO,IAAI,KAAgBmB,GACtB,IAAI,QAAa5U,GAAO,CAC7B,IAAI,QAAsBA,GACxB,OAAOA,EAGT,IAAI6U,EAAe7U,EAAKyT,WACxB,OAAO,IAAI,KAAkBoB,GAG/B,MAAM,IAAI1U,MAAM,2BAA2BnC,OAAOgC,IAGpD,SAASiU,EAAapT,GACpB,IAAI4T,EAAgB,GAEpB,IAAK,IAAI9T,KAAaE,EAAQ,CAC5B,IAAI+F,EAAQ/F,EAAOF,GACf+T,EAAmBZ,EAAWlN,EAAM5G,MAEhB,MAApB0U,GAA4B9N,EAAMrB,OACpCqB,EAAM5G,KAAO0U,EACb9N,EAAMrB,KAAOmO,EAAW9M,EAAMrB,MAC9BkP,EAAc9T,GAAaiG,GAI/B,OAAO6N,EAmBT,SAASP,EAAiBY,GACxB,IAGIC,EAHAC,EAAe,GAEfC,EAAc/b,EAA2B4b,GAG7C,IACE,IAAKG,EAAY1a,MAAOwa,EAAUE,EAAYrb,KAAKY,MAAO,CACxD,IACI0a,EAAcpB,EADDiB,EAAQta,OAGN,MAAfya,GACFF,EAAa/Y,KAAKiZ,IAGtB,MAAOra,GACPoa,EAAYxc,EAAEoC,GACd,QACAoa,EAAYta,IAGd,OAAOqa,EAGT,SAASlB,EAAW9T,GAClB,IAAI,QAAWA,GAAO,CACpB,IAAIkV,EAAcpB,EAAW9T,EAAKE,QAClC,OAAsB,MAAfgV,EAAsB,IAAI,KAAYA,GAAe,KACvD,IAAI,QAAclV,GAAO,CAC9B,IAAImV,EAAerB,EAAW9T,EAAKE,QAEnC,OAAuB,MAAhBiV,EAAuB,IAAI,KAAeA,GAAgB,KAC5D,IAAI,QAAYnV,GAAO,CAC5B,IAAIoV,EAAgBtC,EAAiB9S,EAAKhG,MAO1C,YALsB0F,IAAlB0V,IACFA,EA5OR,SAAqBpV,GACnB,GAAI,cAAeA,EAAM,CACvB,IAAIa,EAASb,EAAK2G,YAElB,IAAK,IAAIhG,KAAaE,EAEpB,MAAsB,UADVA,EAAOF,GACN3G,KAIjB,OAAO,EAkOeqb,CAAYrV,GA/NpC,SAA2BA,GACzB,OAAQA,EAAKhG,MACX,KAAK,UACH,OAAO,KAET,KAAK,UACH,OAAO,KAET,KAAK,UACH,OAAO,KAET,KAAK,UACH,OAAO,KAET,KAAK,UACH,OAAO,KAET,QACE,OAAOgG,GA6M+BsV,CAAkBtV,GAAQsT,EAAgBtT,GAC9EgT,EAAWoC,EAAcpb,MAAQ8Y,EAAiB9S,EAAKhG,MAAQob,GAGzC,MAAjBA,EAAwBpC,EAAWoC,EAAcpb,MAAQ,KAGlE,OAAO,MAIX,SAASub,GAAoBvV,EAAMvF,GACjC,IAAI+a,EAA4Bxc,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,GAAmBA,UAAU,GAAK,KAChGyc,EAA8Bzc,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,GAAmBA,UAAU,GAAK,KAEtG,GAAa,MAATyB,EACF,OAAOA,EAGT,IAAIib,GAAe,QAAgB1V,GAEnC,IAAI,QAAW0V,GACb,OAAoC,MAA7BF,EAAoCA,EAA0BE,EAAcjb,GAASA,EACvF,IAAI,QAAWib,GACpB,OAAOjb,EAAMyE,KAAI,SAAUyW,GACzB,OAAOJ,GAAoBG,EAAaxV,OAAQyV,EAAYH,EAA2BC,MAEpF,IAAI,QAAkBC,GAAe,CAC1C,IAAI7U,EAAS6U,EAAa/O,YACtBnF,EAAW,GAEf,IAAK,IAAIlF,KAAO7B,EAAO,CACrB,IAAImM,EAAQ/F,EAAOvE,GAEN,MAATsK,IACFpF,EAASlF,GAAOiZ,GAAoB3O,EAAM5G,KAAMvF,EAAM6B,GAAMkZ,EAA2BC,IAI3F,OAAsC,MAA/BA,EAAsCA,EAA4BC,EAAclU,GAAYA,GAKvG,SAASoU,GAAoB5V,EAAMvF,GACjC,OAAO8a,GAAoBvV,EAAMvF,GAAO,SAAUob,EAAGC,GACnD,OAAOD,EAAEE,UAAUD,MAIvB,SAASE,GAAgBhW,EAAMvF,GAC7B,OAAO8a,GAAoBvV,EAAMvF,GAAO,SAAUob,EAAGC,GACnD,OAAOD,EAAEI,WAAWH,MAUxB,SAASI,GAAUxU,GACjB,IAAIyU,EAAend,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,GAAmBA,UAAU,GAAK,GACnFga,EAAaoD,GAAaC,GAAUC,GAASC,GAAiBC,GAAcF,GAASC,GAAiB7U,EAAOiB,aAAcjB,EAAQkU,IAAsBlU,EAAQyU,GAAc,SAAUnW,GAC3L,OAAO,QAAWA,MAChB0B,EAAQyU,GAAezU,EAAQsU,IAAkBtU,EAAQyU,GAAc,SAAUnW,GACnF,QAAQ,QAAWA,MACjB0B,EAAQyU,GAAezU,EAAQyU,GAC/BM,EAAqB/U,EAAOsB,gBAC5BuQ,EAAgBmD,GAAcD,EAAoB/U,EAAQyU,GAE1DQ,EAAe/D,GAAYI,EAAYO,GACvCb,EAAUiE,EAAajE,QACvB3P,EAAa4T,EAAa5T,WAE9B,OAAO,IAAI,KAAc7G,EAAcA,EAAc,GAAIwF,EAAO+R,YAAa,GAAI,CAC/EmD,MAAOnE,GAAyBC,EAASD,GAAyBO,EAAYtR,EAAOQ,iBACrF2U,SAAUpE,GAAyBC,EAASD,GAAyBO,EAAYtR,EAAOU,oBACxF0U,aAAcrE,GAAyBC,EAASD,GAAyBO,EAAYtR,EAAOY,wBAC5F2E,MAAOpN,OAAO4G,OAAOiS,GACrB3P,WAAYA,KAIhB,SAASuT,GAASzD,EAAiBnR,EAAQyU,GACzC,IAAIY,EAAS/d,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,GAAmBA,UAAU,GAAK,WAC/E,OAAO,GAELga,EAAa,GAEjB,IAAK,IAAI5P,KAAYyP,EACnB,IAAKzP,EAAS+P,WAAW,MAAO,CAC9B,IAAI6D,EAAenE,EAAgBzP,GAEnC,GAAoB,MAAhB4T,IAAyBD,EAAOC,GAAe,CACjDhE,EAAW5P,GAAY4T,EACvB,SAGF,IAAIC,EAAaC,GAAcxV,EAAQyU,EAAc/S,GAErD,GAAkB,MAAd6T,EAAoB,CACtBjE,EAAW5P,GAAY4T,EACvB,SAGF,IAAIG,EAAeF,EAAWD,EAActV,GAE5C,QAAqBhC,IAAjByX,EAA4B,CAC9BnE,EAAW5P,GAAY4T,EACvB,SAGFhE,EAAW5P,GAAY+T,EAI3B,OAAOnE,EAGT,SAASwD,GAAc3D,EAAiBnR,EAAQyU,GAC9C,IAAIiB,EAwWN,SAA4BjB,GAC1B,IAAIiB,EAAkBjB,EAAa3D,GAAW6E,YAC9C,OAA0B,MAAnBD,EAA0BA,EAAkB,KA1W7BE,CAAmBnB,GAEzC,OAAKiB,EAIEd,GAASzD,EAAiBnR,GAAQ,OAAgB,GAAI8Q,GAAW+E,WAAW,SAAUvX,GAC3F,IAAI+T,EAAS/T,EAAKyT,WACd+D,EAA6BzD,EAAOtT,OACpCgX,EAAwB,GAE5B,IAAK,IAAIC,KAAiBF,EAA4B,CACpD,IAAIG,EAA0BH,EAA2BE,GACrDE,EAAkBR,EAAgBO,EAAyB3X,EAAKhG,KAAM0H,EAAQgW,GAElF,QAAwBhY,IAApBkY,EACFH,EAAsBC,GAAiBC,OAClC,GAAIne,MAAMC,QAAQme,GAAkB,CACzC,IAAIC,GAAmB,OAAeD,EAAiB,GACnDE,EAAmBD,EAAiB,GACpCE,EAAqBF,EAAiB,GAE1CJ,EAAsBK,QAA2CpY,IAAvBqY,EAAmCJ,EAA0BI,OAC1E,OAApBH,IACTH,EAAsBC,GAAiBE,GAI3C,OAAOI,GAAgB,IAAI,KAAgB9b,EAAcA,EAAc,GAAI6X,GAAS,GAAI,CACtFtT,OAAQgX,UAER,SAAUzX,GACZ,OAAO,QAAWA,MA7BX6S,EAiCX,SAAS0D,GAAiB1D,EAAiBnR,EAAQR,GACjD,IAAI8R,EAAaoD,GAAavD,EAAiBnR,GAAQ,OAAgB,GAAI8Q,GAAWyF,UAAU,SAAUC,GACxG,QAAoCxY,IAAhCwY,EAAexR,aACjB,OAAOwR,EAGT,IAAIf,EAAegB,GAAWtF,EAAiBqF,EAAelY,MAE9D,OAAoB,MAAhBmX,EACKjb,EAAcA,EAAc,GAAIgc,GAAiB,GAAI,CAC1DxR,aAAcxF,EAAGiW,EAAce,EAAexR,qBAFlD,MAMF,OAAO2P,GAAUrD,EAAYtR,GAAQ,OAAgB,GAAI8Q,GAAW4F,oBAAoB,SAAUC,GAChG,QAAsC3Y,IAAlC2Y,EAAiB3R,aACnB,OAAO2R,EAGT,IAAIlB,EAAegB,GAAWnF,EAAYqF,EAAiBrY,MAE3D,OAAoB,MAAhBmX,EACKjb,EAAcA,EAAc,GAAImc,GAAmB,GAAI,CAC5D3R,aAAcxF,EAAGiW,EAAckB,EAAiB3R,qBAFpD,MAQJ,SAASyR,GAAWnF,EAAYhT,GAC9B,IAAI,QAAWA,GAAO,CACpB,IAAIsY,EAAUH,GAAWnF,EAAYhT,EAAKE,QAC1C,OAAkB,MAAXoY,EAAkB,IAAI,KAAYA,GAAW,KAC/C,IAAI,QAActY,GAAO,CAC9B,IAAIuY,EAAWJ,GAAWnF,EAAYhT,EAAKE,QAE3C,OAAmB,MAAZqY,EAAmB,IAAI,KAAeA,GAAY,KACpD,IAAI,QAAYvY,GAAO,CAC5B,IAAIwY,EAAYxF,EAAWhT,EAAKhG,MAChC,OAAoB,MAAbwe,EAAoBA,EAAY,KAGzC,OAAO,KAGT,SAASnC,GAAUxD,EAAiBnR,EAAQyU,GAC1C,IAAInD,EAAa,GAEjB,IAAK,IAAI5P,KAAYyP,EACnB,IAAKzP,EAAS+P,WAAW,MAAO,CAC9B,IAAI6D,EAAenE,EAAgBzP,GAEnC,KAAK,QAAa4T,MAAkB,QAAgBA,MAAkB,QAAkBA,GAAe,CACrGhE,EAAW5P,GAAY4T,EACvB,SAGF,IAAIyB,EAAcC,GAAehX,EAAQyU,EAAc/S,GAEvD,GAAmB,MAAfqV,EAAqB,CACvBzF,EAAW5P,GAAY4T,EACvB,SAGF,IAAIjD,EAASiD,EAAavD,WACtBkF,EAAyB5E,EAAOlT,OAChC+X,EAAoB,GAExB,IAAK,IAAIjY,KAAagY,EAAwB,CAC5C,IAAIE,EAAsBF,EAAuBhY,GAC7CmY,EAAcL,EAAYI,EAAqBlY,EAAWyC,EAAU1B,GAExE,QAAoBhC,IAAhBoZ,EACFF,EAAkBjY,GAAakY,OAC1B,GAAIrf,MAAMC,QAAQqf,GAAc,CACrC,IAAIC,GAAe,OAAeD,EAAa,GAC3CE,EAAeD,EAAa,GAC5BE,EAAiBF,EAAa,GAEJ,MAA1BE,EAAelV,UACjBkV,EAAelV,QAAU7H,EAAcA,EAAc,GAAI+c,EAAelV,SAAU,GAAI,CACpF/J,KAAMkC,EAAcA,EAAc,GAAI+c,EAAelV,QAAQ/J,MAAO,GAAI,CACtES,MAAOue,OAKbJ,EAAkBI,QAAmCtZ,IAAnBuZ,EAA+BJ,EAAsBI,OAC9D,OAAhBH,IACTF,EAAkBjY,GAAamY,IAI/B,QAAa9B,GACfhE,EAAW5P,GAAY4U,GAAgB,IAAI,KAAkB9b,EAAcA,EAAc,GAAI6X,GAAS,GAAI,CACxGlT,OAAQ+X,OAED,QAAgB5B,GACzBhE,EAAW5P,GAAY4U,GAAgB,IAAI,KAAqB9b,EAAcA,EAAc,GAAI6X,GAAS,GAAI,CAC3GlT,OAAQ+X,MAGV5F,EAAW5P,GAAY4U,GAAgB,IAAI,KAAuB9b,EAAcA,EAAc,GAAI6X,GAAS,GAAI,CAC7GlT,OAAQ+X,MAMhB,OAAO5F,EAGT,SAASoD,GAAavD,EAAiBnR,EAAQyU,GAC7C,IAAInD,EAAa,GAEjB,IAAK,IAAI5P,KAAYyP,EACnB,IAAKzP,EAAS+P,WAAW,MAAO,CAC9B,IAAI6D,EAAenE,EAAgBzP,GAEnC,KAAK,QAAa4T,MAAkB,QAAgBA,GAAe,CACjEhE,EAAW5P,GAAY4T,EACvB,SAGF,IAAIkC,EAAiBC,GAAkBhD,GAEvC,GAAsB,MAAlB+C,EAAwB,CAC1BlG,EAAW5P,GAAY4T,EACvB,SAGF,IAAIjD,EAASiD,EAAavD,WACtBkF,EAAyB5E,EAAOlT,OAChC+X,EAAoB,GAExB,IAAK,IAAIjY,KAAagY,EAAwB,CAC5C,IAAIE,EAAsBF,EAAuBhY,GAC7CyY,EAA4BP,EAAoBtT,KAEpD,GAAiC,MAA7B6T,EAAJ,CAKA,IAAIC,EAAgBxf,OAAO6B,KAAK0d,GAEhC,GAAKC,EAAcjf,OAAnB,CAOA,IAFA,IAAIkf,EAAuB,GAElBC,EAAM,EAAGC,EAAiBH,EAAeE,EAAMC,EAAepf,OAAQmf,IAAO,CACpF,IAAIE,EAAeD,EAAeD,GAC9BG,EAAyBN,EAA0BK,GACnDE,EAAiBT,EAAeQ,EAAwB/Y,EAAWyC,EAAU1B,GAEjF,QAAuBhC,IAAnBia,EACFL,EAAqBG,GAAgBC,OAChC,GAAIlgB,MAAMC,QAAQkgB,GAAiB,CACxC,IAAIC,GAAkB,OAAeD,EAAgB,GACjDE,EAAkBD,EAAgB,GAClCE,EAAoBF,EAAgB,GAExCN,EAAqBO,GAAmBC,OACZ,OAAnBH,IACTL,EAAqBG,GAAgBE,GAIzCf,EAAkBjY,GAAazE,EAAcA,EAAc,GAAI2c,GAAsB,GAAI,CACvFtT,KAAM+T,SAzBNV,EAAkBjY,GAAakY,OAP/BD,EAAkBjY,GAAakY,GAoC/B,QAAa7B,GACfhE,EAAW5P,GAAY,IAAI,KAAkBlH,EAAcA,EAAc,GAAI6X,GAAS,GAAI,CACxFlT,OAAQ+X,MAED,QAAgB5B,GACzBhE,EAAW5P,GAAY,IAAI,KAAqBlH,EAAcA,EAAc,GAAI6X,GAAS,GAAI,CAC3FlT,OAAQ+X,KAGV5F,EAAW5P,GAAY,IAAI,KAAuBlH,EAAcA,EAAc,GAAI6X,GAAS,GAAI,CAC7FlT,OAAQ+X,KAMhB,OAAO5F,EAGT,SAAS0D,GAAcD,EAAoB/U,EAAQyU,GACjD,IAAI4D,EA2HN,SAA4B5D,GAC1B,IAAI4D,EAAkB5D,EAAa3D,GAAWwH,WAC9C,OAA0B,MAAnBD,EAA0BA,EAAkB,KA7H7BE,CAAmB9D,GAEzC,GAAuB,MAAnB4D,EACF,OAAOtD,EAAmB1c,QAG5B,IAGImgB,EAHA3G,EAAgB,GAEhB4G,EAAcjhB,EAA2Bud,GAG7C,IACE,IAAK0D,EAAY5f,MAAO2f,EAAUC,EAAYvgB,KAAKY,MAAO,CACxD,IAAI0I,EAAYgX,EAAQzf,MACpB2f,EAAkBL,EAAgB7W,EAAWxB,QAEzBhC,IAApB0a,EACF7G,EAActX,KAAKiH,GACU,OAApBkX,GACT7G,EAActX,KAAKme,IAGvB,MAAOvf,GACPsf,EAAY1hB,EAAEoC,GACd,QACAsf,EAAYxf,IAGd,OAAO4Y,EAkCT,SAAS2D,GAAcxV,EAAQyU,EAAc/S,GAM3C,IALA,IACI6T,EADAoD,EAhCN,SAA2B3Y,EAAQ0B,GACjC,IAAItG,EAAIC,EAAIsI,EAERrF,EAAO0B,EAAO4Y,QAAQlX,GACtBiX,EAAa,CAAC7H,GAAW+H,MAwB7B,OAtBI,QAAava,IACfqa,EAAWpe,KAAKuW,GAAWgI,eAAgBhI,GAAWiI,aAElDrX,KAA+C,QAAhCtG,EAAK4E,EAAOQ,sBAAmC,IAAPpF,OAAgB,EAASA,EAAG9C,MACrFqgB,EAAWpe,KAAKuW,GAAWkI,YAAalI,GAAWmI,OAC1CvX,KAAkD,QAAnCrG,EAAK2E,EAAOU,yBAAsC,IAAPrF,OAAgB,EAASA,EAAG/C,MAC/FqgB,EAAWpe,KAAKuW,GAAWkI,YAAalI,GAAWoI,UAC1CxX,KAAsD,QAAvCiC,EAAK3D,EAAOY,6BAA0C,IAAP+C,OAAgB,EAASA,EAAGrL,OACnGqgB,EAAWpe,KAAKuW,GAAWkI,YAAalI,GAAWqI,gBAE5C,QAAkB7a,GAC3Bqa,EAAWpe,KAAKuW,GAAWsI,oBAClB,QAAgB9a,GACzBqa,EAAWpe,KAAKuW,GAAWgI,eAAgBhI,GAAWuI,cAAevI,GAAWwI,iBACvE,QAAYhb,GACrBqa,EAAWpe,KAAKuW,GAAWgI,eAAgBhI,GAAWuI,cAAevI,GAAWyI,aACvE,QAAWjb,GACpBqa,EAAWpe,KAAKuW,GAAW+E,YAClB,QAAavX,IACtBqa,EAAWpe,KAAKuW,GAAW0I,aAGtBb,EAIUc,CAAkBzZ,EAAQ0B,GAGvCgY,GAAQ,OAAmBf,IAEvBpD,GAAcmE,EAAMhhB,OAAS,GAAG,CAGtC6c,EAAad,EADFiF,EAAM7I,OAInB,OAAqB,MAAd0E,EAAqBA,EAAa,KA4B3C,SAASyB,GAAehX,EAAQyU,EAAc/S,GAM5C,IALA,IACIqV,EADA4B,EA1BN,SAA4B3Y,EAAQ0B,GAClC,IAAItG,EAAIC,EAAIsI,EAERrF,EAAO0B,EAAO4Y,QAAQlX,GACtBiX,EAAa,CAAC7H,GAAW6I,OAkB7B,OAhBI,QAAarb,IACfqa,EAAWpe,KAAKuW,GAAW8I,gBAAiB9I,GAAW+I,cAEnDnY,KAA+C,QAAhCtG,EAAK4E,EAAOQ,sBAAmC,IAAPpF,OAAgB,EAASA,EAAG9C,MACrFqgB,EAAWpe,KAAKuW,GAAWgJ,WAAYhJ,GAAWiJ,kBACzCrY,KAAkD,QAAnCrG,EAAK2E,EAAOU,yBAAsC,IAAPrF,OAAgB,EAASA,EAAG/C,MAC/FqgB,EAAWpe,KAAKuW,GAAWgJ,WAAYhJ,GAAWkJ,qBACzCtY,KAAsD,QAAvCiC,EAAK3D,EAAOY,6BAA0C,IAAP+C,OAAgB,EAASA,EAAGrL,OACnGqgB,EAAWpe,KAAKuW,GAAWgJ,WAAYhJ,GAAWmJ,2BAE3C,QAAgB3b,GACzBqa,EAAWpe,KAAKuW,GAAW8I,gBAAiB9I,GAAWoJ,kBAC9C,QAAkB5b,IAC3Bqa,EAAWpe,KAAKuW,GAAW4F,oBAGtBiC,EAIUwB,CAAmBna,EAAQ0B,GAGxCgY,GAAQ,OAAmBf,IAEvB5B,GAAe2C,EAAMhhB,OAAS,GAAG,CAIvCqe,EAActC,EAFHiF,EAAM7I,OAKnB,OAAOkG,MAAAA,EAAiDA,EAAc,KAGxE,SAASU,GAAkBhD,GACzB,IAAI+C,EAAiB/C,EAAa3D,GAAWyF,UAC7C,OAAyB,MAAlBiB,EAAyBA,EAAiB,KAanD,SAASlB,GAAgBhY,GACvB,IAAI,QAAaA,GAAO,CACtB,IAAI+T,EAAS/T,EAAKyT,WAElB,GAAsB,MAAlBM,EAAOhQ,QAAiB,CAC1B,IAAIlD,EAAS,GAEb,IAAK,IAAIF,KAAaoT,EAAOlT,OAAQ,CACnC,IAAIib,EAAc/H,EAAOlT,OAAOF,GAEL,MAAvBmb,EAAY/X,SACdlD,EAAO5E,KAAK6f,EAAY/X,SAI5BgQ,EAAOhQ,QAAU7H,EAAcA,EAAc,GAAI6X,EAAOhQ,SAAU,GAAI,CACpE9G,KAAM,2BACN4D,OAAQA,IAaZ,OATgC,MAA5BkT,EAAO/P,oBACT+P,EAAO/P,kBAAoB+P,EAAO/P,kBAAkB9E,KAAI,SAAUM,GAChE,OAAOtD,EAAcA,EAAc,GAAIsD,GAAO,GAAI,CAChDvC,KAAM,0BACN4D,YAAQnB,QAKP,IAAI,KAAkBqU,GACxB,IAAI,QAAgB/T,GAAO,CAChC,IAAI+b,EAAW/b,EAAKyT,WAEpB,GAAwB,MAApBsI,EAAShY,QAAiB,CAC5B,IAAIiY,EAAU,GAEd,IAAK,IAAIC,KAAcF,EAASlb,OAAQ,CACtC,IAAIqb,EAAeH,EAASlb,OAAOob,GAEP,MAAxBC,EAAanY,SACfiY,EAAQ/f,KAAKigB,EAAanY,SAI9BgY,EAAShY,QAAU7H,EAAcA,EAAc,GAAI6f,EAAShY,SAAU,GAAI,CACxE9G,KAAM,8BACN4D,OAAQmb,IAaZ,OATkC,MAA9BD,EAAS/X,oBACX+X,EAAS/X,kBAAoB+X,EAAS/X,kBAAkB9E,KAAI,SAAUM,GACpE,OAAOtD,EAAcA,EAAc,GAAIsD,GAAO,GAAI,CAChDvC,KAAM,6BACN4D,YAAQnB,QAKP,IAAI,KAAqBqc,GAC3B,IAAI,QAAkB/b,GAAO,CAClC,IAAImc,EAAWnc,EAAKyT,WAEpB,GAAwB,MAApB0I,EAASpY,QAAiB,CAC5B,IAAIqY,EAAW,GAEf,IAAK,IAAIC,KAAeF,EAAStb,OAAQ,CACvC,IAAIyb,EAAgBH,EAAStb,OAAOwb,GAEP,MAAzBC,EAAcvY,SAChBqY,EAASngB,KAAKqgB,EAAcvY,SAIhCoY,EAASpY,QAAU7H,EAAcA,EAAc,GAAIigB,EAASpY,SAAU,GAAI,CACxE9G,KAAM,iCACN4D,OAAQub,IAaZ,OATkC,MAA9BD,EAASnY,oBACXmY,EAASnY,kBAAoBmY,EAASnY,kBAAkB9E,KAAI,SAAUM,GACpE,OAAOtD,EAAcA,EAAc,GAAIsD,GAAO,GAAI,CAChDvC,KAAM,gCACN4D,YAAQnB,QAKP,IAAI,KAAuByc,GAC7B,IAAI,QAAWnc,GAAO,CAC3B,IAAIuc,EAAWvc,EAAKyT,WAEpB,GAAwB,MAApB8I,EAASxY,QAAiB,CAC5B,IAAItD,EAAS,GAEb,IAAK,IAAI+b,KAAWD,EAAS9b,OAAQ,CACnC,IAAIgc,EAAkBF,EAAS9b,OAAO+b,GAEP,MAA3BC,EAAgB1Y,SAClBtD,EAAOxE,KAAKwgB,EAAgB1Y,SAIhCwY,EAASxY,QAAU7H,EAAcA,EAAc,GAAIqgB,EAASxY,SAAU,GAAI,CACxEtD,OAAQA,IAYZ,OARkC,MAA9B8b,EAASvY,oBACXuY,EAASvY,kBAAoBuY,EAASvY,kBAAkB9E,KAAI,SAAUM,GACpE,OAAOtD,EAAcA,EAAc,GAAIsD,GAAO,GAAI,CAChDiB,YAAQf,QAKP,IAAI,KAAgB6c,GAE3B,OAAOvc,EAwHX,SAAS0c,GAAWhb,GAElB,OAGF,SAAmBmR,EAAiB9P,GAClC,IAAI4Z,EAAqB9iB,OAAOkZ,OAAO,MAIvC,IAAK,IAAI3P,KAAYyP,EAAiB,CACpC,IAAIK,EAAYL,EAAgBzP,GAEhC,GAAiB,MAAb8P,IAAqB9P,EAAS+P,WAAW,MAA7C,CAIA,IAAIyJ,EAAa1J,EAAUlZ,KAE3B,IAAI4iB,EAAWzJ,WAAW,MAA1B,CAIA,GAAIyJ,KAAcD,EAChB,MAAM,IAAIxc,MAAM,8BAA8BnC,OAAO4e,IAGvDD,EAAmBC,GAAc1J,IAMnC,IAAK,IAAI2J,KAAcF,EAAoB,CACzC,IAAIG,EAAcH,EAAmBE,GACrChK,EAAgBgK,GAAcC,EAIhC,IACIC,EADAC,EAAc9jB,EAA2B6J,GAG7C,IACE,IAAKia,EAAYziB,MAAOwiB,EAAUC,EAAYpjB,KAAKY,MAAO,CACxD,IAAIyiB,EAAOF,EAAQtiB,MACnBwiB,EAAK1X,KAAO0X,EAAK1X,KAAK1J,QAAO,SAAU2J,GAErC,OADAA,EAAIxF,KAAOkd,EAAS1X,EAAIxF,MACJ,OAAbwF,EAAIxF,SAGf,MAAOnF,GACPmiB,EAAYvkB,EAAEoC,GACd,QACAmiB,EAAYriB,IAGd,IAAK,IAAIwiB,KAActK,EAAiB,CACtC,IAAIuK,EAAcvK,EAAgBsK,IAE7BA,EAAWhK,WAAW,OAASgK,KAAcR,GAC7B,MAAfS,GACFC,EAAcD,GAKpB,IAAK,IAAIE,KAAczK,EAChByK,EAAWnK,WAAW,OAAWmK,KAAcX,UAC3C9J,EAAgByK,GAI3B,SAASD,EAAcrd,GACrB,IAAI,QAAaA,GAGf,OAFAud,EAAWvd,QACXwd,EAAexd,GAEV,IAAI,QAAgBA,GAOzB,OANAud,EAAWvd,QAEP,kBAAmBA,GACrBwd,EAAexd,IAIZ,IAAI,QAAYA,GACrByd,EAAoBzd,QAEf,IAAI,QAAkBA,GAC3B0d,EAAgB1d,QAEX,KAAI,QAAWA,GAItB,MAAM,IAAIG,MAAM,2BAA2BnC,OAAOgC,IAGpD,SAASud,EAAWvd,GAGlB,IAFA,IAAI2d,EAAW3d,EAAK2G,YAEXiX,EAAM,EAAGC,EAAmBhkB,OAAOgF,QAAQ8e,GAAWC,EAAMC,EAAiBzjB,OAAQwjB,IAAO,CACnG,IAAIE,GAAsB,OAAeD,EAAiBD,GAAM,GAC5DthB,EAAMwhB,EAAoB,GAC1BlX,EAAQkX,EAAoB,GAEhClX,EAAMrB,KAAKrG,KAAI,SAAUsG,GAEvB,OADAA,EAAIxF,KAAOkd,EAAS1X,EAAIxF,MACJ,OAAbwF,EAAIxF,KAAgB,KAAOwF,KACjC3J,OAAOxD,SACVuO,EAAM5G,KAAOkd,EAAStW,EAAM5G,MAET,OAAf4G,EAAM5G,aACD2d,EAASrhB,IAKtB,SAASkhB,EAAexd,GACtB,GAAI,kBAAmBA,EAAM,CAC3B,IAAI8G,EAAa9G,EAAK+G,gBACtBD,EAAW7K,KAAKhD,MAAM6N,GAAY,OAAmBA,EAAWiX,OAAO,GAAG7e,KAAI,SAAU8e,GACtF,OAAOd,EAASc,MACfniB,OAAOxD,YAId,SAASqlB,EAAgB1d,GAGvB,IAFA,IAAI2d,EAAW3d,EAAK2G,YAEXsX,EAAM,EAAGC,EAAmBrkB,OAAOgF,QAAQ8e,GAAWM,EAAMC,EAAiB9jB,OAAQ6jB,IAAO,CACnG,IAAIE,GAAsB,OAAeD,EAAiBD,GAAM,GAC5D3hB,EAAM6hB,EAAoB,GAC1BvX,EAAQuX,EAAoB,GAEhCvX,EAAM5G,KAAOkd,EAAStW,EAAM5G,MAET,OAAf4G,EAAM5G,aACD2d,EAASrhB,IAKtB,SAASmhB,EAAoBzd,GAC3B,IAAIiH,EAAQjH,EAAKkH,WACjBD,EAAMhL,KAAKhD,MAAMgO,GAAO,OAAmBA,EAAM8W,OAAO,GAAG7e,KAAI,SAAU2W,GACvE,OAAOqH,EAASrH,MACfha,OAAOxD,WAGZ,SAAS6kB,EAASld,GAEhB,IAAI,QAAWA,GAAO,CACpB,IAAIoe,EAAalB,EAASld,EAAKE,QAC/B,OAAqB,MAAdke,EAAqB,IAAI,KAAYA,GAAc,KACrD,IAAI,QAAcpe,GAAO,CAC9B,IAAIqe,EAAcnB,EAASld,EAAKE,QAEhC,OAAsB,MAAfme,EAAsB,IAAI,KAAeA,GAAe,KAC1D,IAAI,QAAYre,GAAO,CAO5B,IAAIse,EAAezL,EAAgB7S,EAAKhG,MAExC,GAAIskB,GAAgBte,IAASse,EAC3B,OAAOA,EAIX,OAAOte,GA5KTue,CAAU7c,EAAOiB,aAAcjB,EAAOsB,iBAC/BtB,EA0PT,SAAS8c,GAAa9c,EAAQR,GAC5B,IAAIwR,EAAUhR,EAAOiB,aAErB,IAAK,IAAIS,KAAYsP,EAAS,CAC5B,IAAI1S,EAAO0S,EAAQtP,GAEnB,KAAK,QAAapD,GAAMhG,KAAKmZ,WAAW,QAAS,QAAanT,GAAO,CACnE,IAAIa,EAASb,EAAK2G,YAElB,IAAK,IAAIhG,KAAaE,EAAQ,CAE5BK,EADYL,EAAOF,GACTyC,EAAUzC,MAM5B,SAAS8d,GAAoB/c,EAAQR,GACnC,IAAIwR,EAAUhR,EAAOiB,aAErB,IAAK,IAAIS,KAAYsP,EAAS,CAC5B,IAAI1S,EAAO0S,EAAQtP,GAEnB,KAAK,QAAapD,GAAMhG,KAAKmZ,WAAW,MACtC,IAAI,QAAanT,GAAO,CACtB,IAAIa,EAASb,EAAK2G,YAElB,IAAK,IAAIhG,KAAaE,EAAQ,CAC5B,IAGI6d,EADAC,EAAczlB,EAFN2H,EAAOF,GAEgC4E,MAGnD,IACE,IAAKoZ,EAAYpkB,MAAOmkB,EAAUC,EAAY/kB,KAAKY,MAAO,CACxD,IAAIgL,EAAMkZ,EAAQjkB,MAClB+K,EAAIkB,aAAexF,EAAGsE,EAAIxF,KAAMwF,EAAIkB,eAEtC,MAAO7L,GACP8jB,EAAYlmB,EAAEoC,GACd,QACA8jB,EAAYhkB,WAGX,IAAI,QAAkBqF,GAAO,CAClC,IAAI4e,EAAW5e,EAAK2G,YAEpB,IAAK,IAAIkY,KAAeD,EAAU,CAChC,IAAIE,EAASF,EAASC,GACtBC,EAAOpY,aAAexF,EAAG4d,EAAO9e,KAAM8e,EAAOpY,iBAgFvD,SAASqY,GAAYrd,GACnB,IAAIe,EAAUzJ,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,GAAmBA,UAAU,GAAK,GAC9EgmB,EAAiB,CACnBtd,OAAQA,EACRud,YAAaplB,OAAOkZ,OAAO,MAC3BmM,gBAAiBrlB,OAAOkZ,OAAO,OAGjC,IAAK,IAAI3P,KAAY1B,EAAOiB,aAAc,CACxC,IAAI3C,EAAO0B,EAAO4Y,QAAQlX,GAE1B,GAAIpD,GAAQ,kBAAmBA,EAAM,CACnC,IACImf,EADAC,EAAclmB,EAA2B8G,EAAK+G,iBAGlD,IACE,IAAKqY,EAAY7kB,MAAO4kB,EAAUC,EAAYxlB,KAAKY,MAAO,CACxD,IAAIwjB,EAAQmB,EAAQ1kB,MAChBykB,EAAkBG,GAAmBL,EAAgBhB,GAElC,MAAnBkB,IACFF,EAAeE,gBAAgBlB,EAAMhkB,MAAQH,OAAOkZ,OAAO,OAG7DiM,EAAeE,gBAAgBlB,EAAMhkB,MAAMgG,EAAKhG,OAAQ,GAE1D,MAAOa,GACPukB,EAAY3mB,EAAEoC,GACd,QACAukB,EAAYzkB,MAMlB,OADA2kB,GAAWN,EAAgBtd,GACpBwU,GAAUxU,GAAQ,OAAgB,GAAI8Q,GAAW+H,MAAM,SAAUva,GAEtE,GAAIyC,EAAQ8c,aAAe9c,EAAQ8c,YAAYvf,GAC7C,OAAOA,EAGT,IAAI,QAAaA,KAAS,QAAkBA,IAC1C,IAAKnG,OAAO6B,KAAKsE,EAAK2G,aAAavM,SAAWqI,EAAQ+c,+BAAiCR,EAAeC,YAAYjf,EAAKhG,QAAUyI,EAAQgd,uBACvI,OAAO,UAEJ,IAAI,QAAYzf,IACrB,IAAKA,EAAKkH,WAAW9M,SAAWqI,EAAQid,uBAAyBV,EAAeC,YAAYjf,EAAKhG,QAAUyI,EAAQgd,uBACjH,OAAO,UAEJ,IAAI,QAAgBzf,GAAO,CAChC,IAAI2f,EAAmBN,GAAmBL,EAAgBhf,GAE1D,IAAKnG,OAAO6B,KAAKsE,EAAK2G,aAAavM,SAAWqI,EAAQ+c,+BAAiCG,IAAqB9lB,OAAO6B,KAAKikB,GAAkBvlB,SAAWqI,EAAQmd,oCAAsCZ,EAAeC,YAAYjf,EAAKhG,QAAUyI,EAAQgd,uBACnP,OAAO,UAGT,GAAIT,EAAeC,YAAYjf,EAAKhG,QAAUyI,EAAQgd,uBACpD,OAAO,SAMf,SAASI,GAAgBC,EAAcd,EAAgBhf,GACrD,IAAI8f,EAAa9f,EAAKhG,MAOtB,GAHA8lB,EAAa9f,EAAKhG,OAAQ,EAC1BglB,EAAeC,YAAYjf,EAAKhG,OAAQ,GAEpC,QAAagG,KAAS,QAAgBA,GAAO,CAC/C,IAAIa,EAASb,EAAK2G,YAElB,IAAK,IAAIhG,KAAaE,EAAQ,CAC5B,IAAI+F,EAAQ/F,EAAOF,GAEnBkf,GAAgBC,EAAcd,GADd,QAAapY,EAAM5G,OAGnC,IACI+f,EADAC,EAAc9mB,EAA2B0N,EAAMrB,MAGnD,IACE,IAAKya,EAAYzlB,MAAOwlB,EAAUC,EAAYpmB,KAAKY,MAAO,CACxD,IAAIgL,EAAMua,EAAQtlB,MAIlBwlB,GAAeH,EAAcd,GAFjB,QAAaxZ,EAAIxF,QAI/B,MAAOnF,GACPmlB,EAAYvnB,EAAEoC,GACd,QACAmlB,EAAYrlB,KAIhB,IAAI,QAAgBqF,GAAO,CACzB,IAAIkf,EAAkBG,GAAmBL,EAAgBhf,GAEzD,GAAIkf,EACF,IAAK,IAAI9b,KAAY8b,EACnBW,GAAgBC,EAAcd,EAAgBA,EAAetd,OAAO4Y,QAAQlX,IAKlF,GAAI,kBAAmBpD,EAAM,CAC3B,IACIkgB,EADAC,EAAcjnB,EAA2B8G,EAAK+G,iBAGlD,IACE,IAAKoZ,EAAY5lB,MAAO2lB,EAAUC,EAAYvmB,KAAKY,MAAO,CAExDqlB,GAAgBC,EAAcd,EADlBkB,EAAQzlB,QAGtB,MAAOI,GACPslB,EAAY1nB,EAAEoC,GACd,QACAslB,EAAYxlB,WAGX,IAAI,QAAYqF,GAAO,CAC5B,IAGIogB,EADAC,EAAcnnB,EAFN8G,EAAKkH,YAKjB,IACE,IAAKmZ,EAAY9lB,MAAO6lB,EAAUC,EAAYzmB,KAAKY,MAAO,CAExDqlB,GAAgBC,EAAcd,EADjBoB,EAAQ3lB,QAGvB,MAAOI,GACPwlB,EAAY5nB,EAAEoC,GACd,QACAwlB,EAAY1lB,MASlB,SAAS0kB,GAAmBL,EAAgBhf,GAC1C,OAAOgf,EAAeE,gBAAgBlf,EAAKhG,MAG7C,SAASimB,GAAeH,EAAcd,EAAgBhf,GACpD,IAAI8f,EAAa9f,EAAKhG,QAItBglB,EAAeC,YAAYjf,EAAKhG,OAAQ,EACxC8lB,EAAa9f,EAAKhG,OAAQ,GAEtB,QAAkBgG,IAAO,CAC3B,IAAIa,EAASb,EAAK2G,YAElB,IAAK,IAAIhG,KAAaE,EAAQ,CAC5B,IAAI+F,EAAQ/F,EAAOF,GAEnBsf,GAAeH,EAAcd,GADb,QAAapY,EAAM5G,SAMzC,SAASsf,GAAWN,EAAgBtd,GAClC,IAAK,IAAI0B,KAAY1B,EAAOiB,aACrBS,EAAS+P,WAAW,QACvB6L,EAAeC,YAAY7b,IAAY,GAI3C,IAIIkd,EAJAR,EAAejmB,OAAOkZ,OAAO,MAG7BwN,EAAcrnB,EAFF0I,EAAaF,IAK7B,IACE,IAAK6e,EAAYhmB,MAAO+lB,EAAUC,EAAY3mB,KAAKY,MAAO,CAExDqlB,GAAgBC,EAAcd,EADfsB,EAAQ7lB,QAGzB,MAAOI,GACP0lB,EAAY9nB,EAAEoC,GACd,QACA0lB,EAAY5lB,IAGd,IACI6lB,EADAC,EAAcvnB,EAA2BwI,EAAOsB,iBAGpD,IACE,IAAKyd,EAAYlmB,MAAOimB,EAAUC,EAAY7mB,KAAKY,MAAO,CACxD,IAGIkmB,EADAC,EAAcznB,EAFFsnB,EAAQ/lB,MAE+B8K,MAGvD,IACE,IAAKob,EAAYpmB,MAAOmmB,EAAUC,EAAY/mB,KAAKY,MAAO,CACxD,IAAIgL,EAAMkb,EAAQjmB,MAElBwlB,GAAeH,EAAcd,GADlB,QAAaxZ,EAAIxF,QAG9B,MAAOnF,GACP8lB,EAAYloB,EAAEoC,GACd,QACA8lB,EAAYhmB,MAGhB,MAAOE,GACP4lB,EAAYhoB,EAAEoC,GACd,QACA4lB,EAAY9lB,KAKhB,SAASimB,GAAUC,GACjB,IAAIC,EAAmB9nB,UAAUoB,OAAS,QAAsBsF,IAAjB1G,UAAU,IAAmBA,UAAU,GAClFmD,EAAS0kB,EAAQ,IAAM,GACvBE,EAAS,GAETD,GACFjnB,OAAOmnB,eAAeD,EAAQlnB,OAAOkZ,OAAOlZ,OAAOonB,eAAe9kB,KAGpE,IACI+kB,EADAC,EAAcjoB,EAA2B2nB,GAG7C,IACE,IAAKM,EAAY5mB,MAAO2mB,EAAUC,EAAYvnB,KAAKY,MAAO,CACxD,IAAI4B,EAAS8kB,EAAQzmB,MAErB,GAAI2mB,GAASjlB,IAAWilB,GAAShlB,GAAS,CACxC,GAAI0kB,EAAkB,CACpB,IAAIO,EAAkBxnB,OAAOonB,eAAeF,GACxCO,EAAkBznB,OAAOonB,eAAe7kB,GAE5C,GAAIklB,EAAiB,CACnB,IACIC,EADAC,EAActoB,EAA2BW,OAAO4nB,oBAAoBH,IAGxE,IACE,IAAKE,EAAYjnB,MAAOgnB,EAAUC,EAAY5nB,KAAKY,MAAO,CACxD,IAAI8B,EAAMilB,EAAQ9mB,MACdinB,EAAa7nB,OAAOkC,yBAAyBulB,EAAiBhlB,GAE9DmB,EAAOikB,IACT7nB,OAAO4C,eAAe4kB,EAAiB/kB,EAAKolB,IAGhD,MAAO7mB,GACP2mB,EAAY/oB,EAAEoC,GACd,QACA2mB,EAAY7mB,MAKlB,IAAK,IAAIgnB,KAASvlB,EACZglB,GAAShlB,EAAOulB,KACZA,KAASZ,EAGbA,EAAOY,GAASf,GAAU,CAACG,EAAOY,GAAQvlB,EAAOulB,IAASb,GAG5DjnB,OAAO+nB,OAAOb,GAAQ,OAAgB,GAAIY,EAAOvlB,EAAOulB,OAKhE,MAAO9mB,GACPsmB,EAAY1oB,EAAEoC,GACd,QACAsmB,EAAYxmB,IAGd,OAAOomB,EAGT,SAASK,GAASS,GAChB,OAAOA,GAAwB,iBAATA,IAAsBroB,MAAMC,QAAQooB,IA3qD5D,SAAWrP,GACTA,EAAiB,KAAI,kBACrBA,EAAwB,YAAI,yBAC5BA,EAAsB,UAAI,uBAC1BA,EAA2B,eAAI,4BAC/BA,EAAwB,YAAI,yBAC5BA,EAA8B,kBAAI,+BAClCA,EAA0B,cAAI,2BAC9BA,EAAuB,WAAI,wBAC3BA,EAA2B,eAAI,4BAC/BA,EAAwB,YAAI,yBAC5BA,EAAkB,MAAI,mBACtBA,EAAqB,SAAI,sBACzBA,EAAyB,aAAI,0BAC7BA,EAAsB,UAAI,uBAC1BA,EAAkB,MAAI,mBACtBA,EAA4B,gBAAI,6BAChCA,EAAyB,aAAI,0BAC7BA,EAAuB,WAAI,wBAC3BA,EAA6B,iBAAI,8BACjCA,EAAgC,oBAAI,iCACpCA,EAAoC,wBAAI,qCACxCA,EAA4B,gBAAI,6BAChCA,EAA+B,mBAAI,gCACnCA,EAAqB,SAAI,sBACzBA,EAAuB,WAAI,wBAzB7B,CA0BGA,KAAeA,GAAa,KAsoEEvR,GAAS,SAAoC6gB,GAC5E,OAXF,SAAqCC,EAAcC,GACjD,IAAIC,GAAM,OAAgBF,EAAcC,GAExC,IAAKC,EACH,MAAM,IAAI9hB,MAAM,0BAA0BnC,OAAOgkB,GAAiB,KAGpE,OAAOC,EAIAC,CAA4BJ,EAAQK,SAAUL,EAAQE,kBAG/D,SAASI,GAAc1gB,EAAQ2gB,EAAWC,EAAgBC,EAAalX,EAAcxK,EAAQ2hB,GAC3F,IACIC,EAkHoBjjB,EAnHpBkjB,EAAcxpB,EAA2BmS,EAAaM,YAG1D,IACE,IAAK+W,EAAYnoB,MAAOkoB,EAAUC,EAAY9oB,KAAKY,MAAO,CACxD,IAAImoB,EAAYF,EAAQhoB,MAExB,OAAQkoB,EAAU1lB,MAChB,KAAK,UAED,IAAK2lB,GAAkBN,EAAgBK,GACrC,SAGF,IAAI3oB,GAqGUwF,EArGcmjB,GAsG1B3lB,MAAQwC,EAAKxC,MAAMvC,MAAQ+E,EAAKxF,KAAKS,MArGnCooB,EAAYhiB,EAAOU,IAAIvH,QAET0F,IAAdmjB,EACFA,EAAU5mB,KAAK0mB,GAEf9hB,EAAOY,IAAIzH,EAAM,CAAC2oB,IAGpB,MAGJ,KAAK,oBAED,IAAKC,GAAkBN,EAAgBK,KAAeG,GAA2BphB,EAAQihB,EAAWJ,GAClG,SAGFH,GAAc1gB,EAAQ2gB,EAAWC,EAAgBC,EAAaI,EAAUtX,aAAcxK,EAAQ2hB,GAC9F,MAGJ,KAAK,oBAED,IAAIO,EAAWJ,EAAU3oB,KAAKS,MAE9B,GAAI+nB,EAAqBQ,IAAID,KAAcH,GAAkBN,EAAgBK,GAC3E,SAGFH,EAAqBS,IAAIF,GACzB,IAAIG,EAAWb,EAAUU,GAEzB,IAAKG,IAAaJ,GAA2BphB,EAAQwhB,EAAUX,GAC7D,SAGFH,GAAc1gB,EAAQ2gB,EAAWC,EAAgBC,EAAaW,EAAS7X,aAAcxK,EAAQ2hB,KAKrG,MAAO3nB,GACP6nB,EAAYjqB,EAAEoC,GACd,QACA6nB,EAAY/nB,IAGd,OAAOkG,EAQT,SAAS+hB,GAAkBN,EAAgB9iB,GACzC,IAAI2jB,GAAO,QAAmB,KAAsB3jB,EAAM8iB,GAE1D,IAAiE,KAA5Da,MAAAA,OAAmC,EAASA,EAAS,IACxD,OAAO,EAGT,IAAIC,GAAU,QAAmB,KAAyB5jB,EAAM8iB,GAEhE,OAA0E,KAArEc,MAAAA,OAAyC,EAASA,EAAY,IAWrE,SAASN,GAA2BphB,EAAQwhB,EAAUljB,GACpD,IAAIqjB,EAAoBH,EAAS5W,cAEjC,IAAK+W,EACH,OAAO,EAGT,IAAIC,GAAkB,OAAY5hB,EAAQ2hB,GAE1C,OAAIC,IAAoBtjB,MAIpB,QAAesjB,IACG5hB,EAAO6hB,iBAAiBD,GACvBplB,SAAS8B,GAclC,IAj8IkBkB,GACZsiB,GADYtiB,GAi8Ic,SAA0BQ,EAAQ2gB,EAAWC,EAAgBtiB,EAAMU,GACjG,IAII+iB,EAJAC,EAAgB,IAAI1hB,IACpBwgB,EAAuB,IAAI3gB,IAE3B8hB,EAAczqB,EAA2BwH,GAG7C,IACE,IAAKijB,EAAYppB,MAAOkpB,EAAUE,EAAY/pB,KAAKY,MAAO,CACxD,IAAIopB,EAAYH,EAAQhpB,MAEpBmpB,EAAUvY,cACZ+W,GAAc1gB,EAAQ2gB,EAAWC,EAAgBtiB,EAAM4jB,EAAUvY,aAAcqY,EAAelB,IAGlG,MAAO3nB,GACP8oB,EAAYlrB,EAAEoC,GACd,QACA8oB,EAAYhpB,IAGd,OAAO+oB,GAr9IHF,GAAgB,IAAIpiB,QAkyJ1B,SAASyiB,GAAeroB,GACtB,OAAOA,GAA4B,iBAAXA,GAAuB,SAAUA,GAAUA,EAAOyB,OAAS","sources":["webpack:///./node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/index.mjs"],"sourcesContent":["import _asyncToGenerator from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _wrapNativeSuper from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _defineProperty from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/ks.choi/graphql.github.io/node_modules/@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { parse, isNonNullType, GraphQLError, Kind, valueFromAST, print, isObjectType, isListType, isSpecifiedDirective, astFromValue, isSpecifiedScalarType, isIntrospectionType, isInterfaceType, isUnionType, isInputObjectType, isEnumType, isScalarType, GraphQLDeprecatedDirective, specifiedRules, concatAST, validate, versionInfo, buildClientSchema, visit, TokenKind, Source, isTypeSystemDefinitionNode, getNamedType, GraphQLString, GraphQLNonNull, GraphQLList, GraphQLID, GraphQLBoolean, GraphQLFloat, GraphQLInt, GraphQLObjectType, GraphQLInterfaceType, GraphQLInputObjectType, GraphQLDirective, GraphQLUnionType, GraphQLEnumType, GraphQLScalarType, isNamedType, getNullableType, isLeafType, GraphQLSchema, isDirective, isCompositeType, doTypesOverlap, getOperationAST, getDirectiveValues, GraphQLSkipDirective, GraphQLIncludeDirective, typeFromAST, isAbstractType, getOperationRootType, TypeNameMetaFieldDef, buildASTSchema } from 'graphql';\n\nvar asArray = function asArray(fns) {\n  return Array.isArray(fns) ? fns : fns ? [fns] : [];\n};\n\nvar invalidDocRegex = /\\.[a-z0-9]+$/i;\n\nfunction isDocumentString(str) {\n  if (typeof str !== 'string') {\n    return false;\n  } // XXX: is-valid-path or is-glob treat SDL as a valid path\n  // (`scalar Date` for example)\n  // this why checking the extension is fast enough\n  // and prevent from parsing the string in order to find out\n  // if the string is a SDL\n\n\n  if (invalidDocRegex.test(str)) {\n    return false;\n  }\n\n  try {\n    parse(str);\n    return true;\n  } catch (e) {}\n\n  return false;\n}\n\nvar invalidPathRegex = /[!%&^<=>`]/;\n\nfunction isValidPath(str) {\n  return typeof str === 'string' && !invalidPathRegex.test(str);\n}\n\nfunction compareStrings(a, b) {\n  if (String(a) < String(b)) {\n    return -1;\n  }\n\n  if (String(a) > String(b)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction nodeToString(a) {\n  var _a, _b;\n\n  var name;\n\n  if ('alias' in a) {\n    name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;\n  }\n\n  if (name == null && 'name' in a) {\n    name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;\n  }\n\n  if (name == null) {\n    name = a.kind;\n  }\n\n  return name;\n}\n\nfunction compareNodes(a, b, customFn) {\n  var aStr = nodeToString(a);\n  var bStr = nodeToString(b);\n\n  if (typeof customFn === 'function') {\n    return customFn(aStr, bStr);\n  }\n\n  return compareStrings(aStr, bStr);\n}\n\nfunction isSome(input) {\n  return input != null;\n}\n\nfunction assertSome(input) {\n  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Value should be something';\n\n  if (input == null) {\n    throw new Error(message);\n  }\n} // Taken from graphql-js\n// https://github.com/graphql/graphql-js/blob/main/src/jsutils/inspect.ts\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (typeof value) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (value === null) {\n    return 'null';\n  }\n\n  if (previouslySeenValues.includes(value)) {\n    return '[Circular]';\n  }\n\n  var seenValues = [].concat(_toConsumableArray(previouslySeenValues), [value]);\n\n  if (isJSONable(value)) {\n    var jsonValue = value.toJSON(); // check for infinite recursion\n\n    if (jsonValue !== value) {\n      return typeof jsonValue === 'string' ? jsonValue : formatValue(jsonValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction isJSONable(value) {\n  return typeof value.toJSON === 'function';\n}\n\nfunction formatObject(object, seenValues) {\n  var entries = Object.entries(object);\n\n  if (entries.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = entries.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    return key + ': ' + formatValue(value, seenValues);\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \".concat(remaining, \" more items\"));\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getObjectTag(object) {\n  var tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    var name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getArgumentValues(def, node) {\n  var variableValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  var variableMap = Object.entries(variableValues).reduce(function (prev, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        key = _ref4[0],\n        value = _ref4[1];\n\n    return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, key, value));\n  }, {});\n  var coercedValues = {}; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  var argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n  var argNodeMap = argumentNodes.reduce(function (prev, arg) {\n    return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, arg.name.value, arg));\n  }, {});\n\n  var _iterator = _createForOfIteratorHelper(def.args),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          name = _step$value.name,\n          argType = _step$value.type,\n          defaultValue = _step$value.defaultValue;\n      var argumentNode = argNodeMap[name];\n\n      if (!argumentNode) {\n        if (defaultValue !== undefined) {\n          coercedValues[name] = defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + 'was not provided.', node);\n        }\n\n        continue;\n      }\n\n      var valueNode = argumentNode.value;\n      var isNull = valueNode.kind === Kind.NULL;\n\n      if (valueNode.kind === Kind.VARIABLE) {\n        var variableName = valueNode.name.value;\n\n        if (variableValues == null || !variableMap[variableName]) {\n          if (defaultValue !== undefined) {\n            coercedValues[name] = defaultValue;\n          } else if (isNonNullType(argType)) {\n            throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + \"was provided the variable \\\"$\".concat(variableName, \"\\\" which was not provided a runtime value.\"), valueNode);\n          }\n\n          continue;\n        }\n\n        isNull = variableValues[variableName] == null;\n      }\n\n      if (isNull && isNonNullType(argType)) {\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of non-null type \\\"\").concat(inspect(argType), \"\\\" \") + 'must not be null.', valueNode);\n      }\n\n      var coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n      if (coercedValue === undefined) {\n        // Note: ValuesOfCorrectTypeRule validation should catch this before\n        // execution. This is a runtime check to ensure execution does not\n        // continue with an invalid argument value.\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" has invalid value \").concat(print(valueNode), \".\"), valueNode);\n      }\n\n      coercedValues[name] = coercedValue;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return coercedValues;\n}\n\nfunction getDirectivesInExtensions(node) {\n  var pathToDirectivesInExtensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['directives'];\n  return pathToDirectivesInExtensions.reduce(function (acc, pathSegment) {\n    return acc == null ? acc : acc[pathSegment];\n  }, node === null || node === void 0 ? void 0 : node.extensions);\n}\n\nfunction _getDirectiveInExtensions(directivesInExtensions, directiveName) {\n  var directiveInExtensions = directivesInExtensions.filter(function (directiveAnnotation) {\n    return directiveAnnotation.name === directiveName;\n  });\n\n  if (!directiveInExtensions.length) {\n    return undefined;\n  }\n\n  return directiveInExtensions.map(function (directive) {\n    var _a;\n\n    return (_a = directive.args) !== null && _a !== void 0 ? _a : {};\n  });\n}\n\nfunction getDirectiveInExtensions(node, directiveName) {\n  var pathToDirectivesInExtensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['directives'];\n  var directivesInExtensions = pathToDirectivesInExtensions.reduce(function (acc, pathSegment) {\n    return acc == null ? acc : acc[pathSegment];\n  }, node === null || node === void 0 ? void 0 : node.extensions);\n\n  if (directivesInExtensions === undefined) {\n    return undefined;\n  }\n\n  if (Array.isArray(directivesInExtensions)) {\n    return _getDirectiveInExtensions(directivesInExtensions, directiveName);\n  } // Support condensed format by converting to longer format\n  // The condensed format does not preserve ordering of directives when  repeatable directives are used.\n  // See https://github.com/ardatan/graphql-tools/issues/2534\n\n\n  var reformattedDirectivesInExtensions = [];\n\n  for (var _i = 0, _Object$entries = Object.entries(directivesInExtensions); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        name = _Object$entries$_i[0],\n        argsOrArrayOfArgs = _Object$entries$_i[1];\n\n    if (Array.isArray(argsOrArrayOfArgs)) {\n      var _iterator2 = _createForOfIteratorHelper(argsOrArrayOfArgs),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var args = _step2.value;\n          reformattedDirectivesInExtensions.push({\n            name: name,\n            args: args\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else {\n      reformattedDirectivesInExtensions.push({\n        name: name,\n        args: argsOrArrayOfArgs\n      });\n    }\n  }\n\n  return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);\n}\n\nfunction getDirectives(schema, node) {\n  var pathToDirectivesInExtensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['directives'];\n  var directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);\n\n  if (directivesInExtensions != null && directivesInExtensions.length > 0) {\n    return directivesInExtensions;\n  }\n\n  var schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n  var schemaDirectiveMap = schemaDirectives.reduce(function (schemaDirectiveMap, schemaDirective) {\n    schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n    return schemaDirectiveMap;\n  }, {});\n  var astNodes = [];\n\n  if (node.astNode) {\n    astNodes.push(node.astNode);\n  }\n\n  if ('extensionASTNodes' in node && node.extensionASTNodes) {\n    astNodes = [].concat(_toConsumableArray(astNodes), _toConsumableArray(node.extensionASTNodes));\n  }\n\n  var result = [];\n\n  var _iterator3 = _createForOfIteratorHelper(astNodes),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var astNode = _step3.value;\n\n      if (astNode.directives) {\n        var _iterator4 = _createForOfIteratorHelper(astNode.directives),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var directiveNode = _step4.value;\n            var schemaDirective = schemaDirectiveMap[directiveNode.name.value];\n\n            if (schemaDirective) {\n              result.push({\n                name: directiveNode.name.value,\n                args: getArgumentValues(schemaDirective, directiveNode)\n              });\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return result;\n}\n\nfunction getDirective(schema, node, directiveName) {\n  var pathToDirectivesInExtensions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ['directives'];\n  var directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);\n\n  if (directiveInExtensions != null) {\n    return directiveInExtensions;\n  }\n\n  var schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;\n\n  if (schemaDirective == null) {\n    return undefined;\n  }\n\n  var astNodes = [];\n\n  if (node.astNode) {\n    astNodes.push(node.astNode);\n  }\n\n  if ('extensionASTNodes' in node && node.extensionASTNodes) {\n    astNodes = [].concat(_toConsumableArray(astNodes), _toConsumableArray(node.extensionASTNodes));\n  }\n\n  var result = [];\n\n  var _iterator5 = _createForOfIteratorHelper(astNodes),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var astNode = _step5.value;\n\n      if (astNode.directives) {\n        var _iterator6 = _createForOfIteratorHelper(astNode.directives),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var directiveNode = _step6.value;\n\n            if (directiveNode.name.value === directiveName) {\n              result.push(getArgumentValues(schemaDirective, directiveNode));\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  if (!result.length) {\n    return undefined;\n  }\n\n  return result;\n}\n\nfunction parseDirectiveValue(value) {\n  switch (value.kind) {\n    case Kind.INT:\n      return parseInt(value.value);\n\n    case Kind.FLOAT:\n      return parseFloat(value.value);\n\n    case Kind.BOOLEAN:\n      return Boolean(value.value);\n\n    case Kind.STRING:\n    case Kind.ENUM:\n      return value.value;\n\n    case Kind.LIST:\n      return value.values.map(function (v) {\n        return parseDirectiveValue(v);\n      });\n\n    case Kind.OBJECT:\n      return value.fields.reduce(function (prev, v) {\n        return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, v.name.value, parseDirectiveValue(v.value)));\n      }, {});\n\n    case Kind.NULL:\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction getFieldsWithDirectives(documentNode) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var result = {};\n  var selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n\n  if (options.includeInputTypes) {\n    selected = [].concat(_toConsumableArray(selected), ['InputObjectTypeDefinition', 'InputObjectTypeExtension']);\n  }\n\n  var allTypes = documentNode.definitions.filter(function (obj) {\n    return selected.includes(obj.kind);\n  });\n\n  var _iterator7 = _createForOfIteratorHelper(allTypes),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var type = _step7.value;\n      var typeName = type.name.value;\n\n      if (type.fields == null) {\n        continue;\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(type.fields),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var field = _step8.value;\n\n          if (field.directives && field.directives.length > 0) {\n            var fieldName = field.name.value;\n            var key = \"\".concat(typeName, \".\").concat(fieldName);\n            var directives = field.directives.map(function (d) {\n              return {\n                name: d.name.value,\n                args: (d.arguments || []).reduce(function (prev, arg) {\n                  return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, arg.name.value, parseDirectiveValue(arg.value)));\n                }, {})\n              };\n            });\n            result[key] = directives;\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return result;\n}\n\nfunction getImplementingTypes(interfaceName, schema) {\n  var allTypesMap = schema.getTypeMap();\n  var result = [];\n\n  for (var graphqlTypeName in allTypesMap) {\n    var graphqlType = allTypesMap[graphqlTypeName];\n\n    if (isObjectType(graphqlType)) {\n      var allInterfaces = graphqlType.getInterfaces();\n\n      if (allInterfaces.find(function (int) {\n        return int.name === interfaceName;\n      })) {\n        result.push(graphqlType.name);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction astFromType(type) {\n  if (isNonNullType(type)) {\n    var innerType = astFromType(type.ofType);\n\n    if (innerType.kind === Kind.NON_NULL_TYPE) {\n      throw new Error(\"Invalid type node \".concat(inspect(type), \". Inner type of non-null type cannot be a non-null type.\"));\n    }\n\n    return {\n      kind: Kind.NON_NULL_TYPE,\n      type: innerType\n    };\n  } else if (isListType(type)) {\n    return {\n      kind: Kind.LIST_TYPE,\n      type: astFromType(type.ofType)\n    };\n  }\n\n  return {\n    kind: Kind.NAMED_TYPE,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    }\n  };\n}\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | null          | NullValue            |\n *\n */\n\n\nfunction astFromValueUntyped(value) {\n  // only explicit null, not undefined, NaN\n  if (value === null) {\n    return {\n      kind: Kind.NULL\n    };\n  } // undefined\n\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if (Array.isArray(value)) {\n    var valuesNodes = [];\n\n    var _iterator9 = _createForOfIteratorHelper(value),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var item = _step9.value;\n        var itemNode = astFromValueUntyped(item);\n\n        if (itemNode != null) {\n          valuesNodes.push(itemNode);\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return {\n      kind: Kind.LIST,\n      values: valuesNodes\n    };\n  }\n\n  if (typeof value === 'object') {\n    var fieldNodes = [];\n\n    for (var fieldName in value) {\n      var fieldValue = value[fieldName];\n      var ast = astFromValueUntyped(fieldValue);\n\n      if (ast) {\n        fieldNodes.push({\n          kind: Kind.OBJECT_FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: fieldName\n          },\n          value: ast\n        });\n      }\n    }\n\n    return {\n      kind: Kind.OBJECT,\n      fields: fieldNodes\n    };\n  } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n  if (typeof value === 'boolean') {\n    return {\n      kind: Kind.BOOLEAN,\n      value: value\n    };\n  } // JavaScript numbers can be Int or Float values.\n\n\n  if (typeof value === 'number' && isFinite(value)) {\n    var stringNum = String(value);\n    return integerStringRegExp.test(stringNum) ? {\n      kind: Kind.INT,\n      value: stringNum\n    } : {\n      kind: Kind.FLOAT,\n      value: stringNum\n    };\n  }\n\n  if (typeof value === 'string') {\n    return {\n      kind: Kind.STRING,\n      value: value\n    };\n  }\n\n  throw new TypeError(\"Cannot convert value to AST: \".concat(value, \".\"));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\n\nvar integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n\nfunction memoize1(fn) {\n  var memoize1cache = new WeakMap();\n  return function memoized(a1) {\n    var cachedValue = memoize1cache.get(a1);\n\n    if (cachedValue === undefined) {\n      var newValue = fn(a1);\n      memoize1cache.set(a1, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize2(fn) {\n  var memoize2cache = new WeakMap();\n  return function memoized(a1, a2) {\n    var cache2 = memoize2cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize2cache.set(a1, cache2);\n      var newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    var cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      var _newValue = fn(a1, a2);\n\n      cache2.set(a2, _newValue);\n      return _newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize3(fn) {\n  var memoize3Cache = new WeakMap();\n  return function memoized(a1, a2, a3) {\n    var cache2 = memoize3Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize3Cache.set(a1, cache2);\n\n      var _cache = new WeakMap();\n\n      cache2.set(a2, _cache);\n      var newValue = fn(a1, a2, a3);\n\n      _cache.set(a3, newValue);\n\n      return newValue;\n    }\n\n    var cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n\n      var _newValue2 = fn(a1, a2, a3);\n\n      cache3.set(a3, _newValue2);\n      return _newValue2;\n    }\n\n    var cachedValue = cache3.get(a3);\n\n    if (cachedValue === undefined) {\n      var _newValue3 = fn(a1, a2, a3);\n\n      cache3.set(a3, _newValue3);\n      return _newValue3;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize4(fn) {\n  var memoize4Cache = new WeakMap();\n  return function memoized(a1, a2, a3, a4) {\n    var cache2 = memoize4Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize4Cache.set(a1, cache2);\n\n      var _cache2 = new WeakMap();\n\n      cache2.set(a2, _cache2);\n\n      var _cache3 = new WeakMap();\n\n      _cache2.set(a3, _cache3);\n\n      var newValue = fn(a1, a2, a3, a4);\n\n      _cache3.set(a4, newValue);\n\n      return newValue;\n    }\n\n    var cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n\n      var _cache4 = new WeakMap();\n\n      cache3.set(a3, _cache4);\n\n      var _newValue4 = fn(a1, a2, a3, a4);\n\n      _cache4.set(a4, _newValue4);\n\n      return _newValue4;\n    }\n\n    var cache4 = cache3.get(a3);\n\n    if (!cache4) {\n      var _cache5 = new WeakMap();\n\n      cache3.set(a3, _cache5);\n\n      var _newValue5 = fn(a1, a2, a3, a4);\n\n      _cache5.set(a4, _newValue5);\n\n      return _newValue5;\n    }\n\n    var cachedValue = cache4.get(a4);\n\n    if (cachedValue === undefined) {\n      var _newValue6 = fn(a1, a2, a3, a4);\n\n      cache4.set(a4, _newValue6);\n      return _newValue6;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize5(fn) {\n  var memoize5Cache = new WeakMap();\n  return function memoized(a1, a2, a3, a4, a5) {\n    var cache2 = memoize5Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize5Cache.set(a1, cache2);\n\n      var _cache6 = new WeakMap();\n\n      cache2.set(a2, _cache6);\n\n      var _cache7 = new WeakMap();\n\n      _cache6.set(a3, _cache7);\n\n      var _cache8 = new WeakMap();\n\n      _cache7.set(a4, _cache8);\n\n      var newValue = fn(a1, a2, a3, a4, a5);\n\n      _cache8.set(a5, newValue);\n\n      return newValue;\n    }\n\n    var cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n\n      var _cache9 = new WeakMap();\n\n      cache3.set(a3, _cache9);\n\n      var _cache10 = new WeakMap();\n\n      _cache9.set(a4, _cache10);\n\n      var _newValue7 = fn(a1, a2, a3, a4, a5);\n\n      _cache10.set(a5, _newValue7);\n\n      return _newValue7;\n    }\n\n    var cache4 = cache3.get(a3);\n\n    if (!cache4) {\n      cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n\n      var _cache11 = new WeakMap();\n\n      cache4.set(a4, _cache11);\n\n      var _newValue8 = fn(a1, a2, a3, a4, a5);\n\n      _cache11.set(a5, _newValue8);\n\n      return _newValue8;\n    }\n\n    var cache5 = cache4.get(a4);\n\n    if (!cache5) {\n      cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n\n      var _newValue9 = fn(a1, a2, a3, a4, a5);\n\n      cache5.set(a5, _newValue9);\n      return _newValue9;\n    }\n\n    var cachedValue = cache5.get(a5);\n\n    if (cachedValue === undefined) {\n      var _newValue10 = fn(a1, a2, a3, a4, a5);\n\n      cache5.set(a5, _newValue10);\n      return _newValue10;\n    }\n\n    return cachedValue;\n  };\n}\n\nvar memoize2of4cache = new WeakMap();\n\nfunction memoize2of4(fn) {\n  return function memoized(a1, a2, a3, a4) {\n    var cache2 = memoize2of4cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize2of4cache.set(a1, cache2);\n      var newValue = fn(a1, a2, a3, a4);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    var cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      var _newValue11 = fn(a1, a2, a3, a4);\n\n      cache2.set(a2, _newValue11);\n      return _newValue11;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction getDefinedRootType(schema, operation) {\n  var rootTypeMap = getRootTypeMap(schema);\n  var rootType = rootTypeMap.get(operation);\n\n  if (rootType == null) {\n    throw new Error(\"Root type for operation \\\"\".concat(operation, \"\\\" not defined by the given schema.\"));\n  }\n\n  return rootType;\n}\n\nvar getRootTypeNames = memoize1(function getRootTypeNames(schema) {\n  var rootTypes = getRootTypes(schema);\n  return new Set(_toConsumableArray(rootTypes).map(function (type) {\n    return type.name;\n  }));\n});\nvar getRootTypes = memoize1(function getRootTypes(schema) {\n  var rootTypeMap = getRootTypeMap(schema);\n  return new Set(rootTypeMap.values());\n});\nvar getRootTypeMap = memoize1(function getRootTypeMap(schema) {\n  var rootTypeMap = new Map();\n  var queryType = schema.getQueryType();\n\n  if (queryType) {\n    rootTypeMap.set('query', queryType);\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    rootTypeMap.set('mutation', mutationType);\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    rootTypeMap.set('subscription', subscriptionType);\n  }\n\n  return rootTypeMap;\n});\n\nfunction getDocumentNodeFromSchema(schema) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n  var typesMap = schema.getTypeMap();\n  var schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n  var definitions = schemaNode != null ? [schemaNode] : [];\n  var directives = schema.getDirectives();\n\n  var _iterator10 = _createForOfIteratorHelper(directives),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var directive = _step10.value;\n\n      if (isSpecifiedDirective(directive)) {\n        continue;\n      }\n\n      definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  for (var typeName in typesMap) {\n    var type = typesMap[typeName];\n    var isPredefinedScalar = isSpecifiedScalarType(type);\n    var isIntrospection = isIntrospectionType(type);\n\n    if (isPredefinedScalar || isIntrospection) {\n      continue;\n    }\n\n    if (isObjectType(type)) {\n      definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n    } else if (isInterfaceType(type)) {\n      definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n    } else if (isUnionType(type)) {\n      definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n    } else if (isInputObjectType(type)) {\n      definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n    } else if (isEnumType(type)) {\n      definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n    } else if (isScalarType(type)) {\n      definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n    } else {\n      throw new Error(\"Unknown type \".concat(type, \".\"));\n    }\n  }\n\n  return {\n    kind: Kind.DOCUMENT,\n    definitions: definitions\n  };\n} // this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\n\n\nfunction printSchemaWithDirectives(schema) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var documentNode = getDocumentNodeFromSchema(schema, options);\n  return print(documentNode);\n}\n\nfunction astFromSchema(schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  var operationTypeMap = new Map([['query', undefined], ['mutation', undefined], ['subscription', undefined]]);\n  var nodes = [];\n\n  if (schema.astNode != null) {\n    nodes.push(schema.astNode);\n  }\n\n  if (schema.extensionASTNodes != null) {\n    var _iterator11 = _createForOfIteratorHelper(schema.extensionASTNodes),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var extensionASTNode = _step11.value;\n        nodes.push(extensionASTNode);\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n  }\n\n  for (var _i2 = 0, _nodes = nodes; _i2 < _nodes.length; _i2++) {\n    var node = _nodes[_i2];\n\n    if (node.operationTypes) {\n      var _iterator12 = _createForOfIteratorHelper(node.operationTypes),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var operationTypeDefinitionNode = _step12.value;\n          operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  }\n\n  var rootTypeMap = getRootTypeMap(schema);\n\n  var _iterator13 = _createForOfIteratorHelper(operationTypeMap),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var _step13$value = _slicedToArray(_step13.value, 2),\n          operationTypeNode = _step13$value[0],\n          _operationTypeDefinitionNode = _step13$value[1];\n\n      var rootType = rootTypeMap.get(operationTypeNode);\n\n      if (rootType != null) {\n        var rootTypeAST = astFromType(rootType);\n\n        if (_operationTypeDefinitionNode != null) {\n          _operationTypeDefinitionNode.type = rootTypeAST;\n        } else {\n          operationTypeMap.set(operationTypeNode, {\n            kind: Kind.OPERATION_TYPE_DEFINITION,\n            operation: operationTypeNode,\n            type: rootTypeAST\n          });\n        }\n      }\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  var operationTypes = _toConsumableArray(operationTypeMap.values()).filter(isSome);\n\n  var directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n\n  if (!operationTypes.length && !directives.length) {\n    return null;\n  }\n\n  var schemaNode = {\n    kind: operationTypes != null ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,\n    operationTypes: operationTypes,\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: directives\n  }; // This code is so weird because it needs to support GraphQL.js 14\n  // In GraphQL.js 14 there is no `description` value on schemaNode\n\n  schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {\n    kind: Kind.STRING,\n    value: schema.description,\n    block: true\n  } : undefined;\n  return schemaNode;\n}\n\nfunction astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c, _d;\n\n  return {\n    kind: Kind.DIRECTIVE_DEFINITION,\n    description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {\n      kind: Kind.STRING,\n      value: directive.description\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: directive.name\n    },\n    arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map(function (arg) {\n      return astFromArg(arg, schema, pathToDirectivesInExtensions);\n    }),\n    repeatable: directive.isRepeatable,\n    locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map(function (location) {\n      return {\n        kind: Kind.NAME,\n        value: location\n      };\n    })) || []\n  };\n}\n\nfunction getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n  var directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n  var nodes = [];\n\n  if (entity.astNode != null) {\n    nodes.push(entity.astNode);\n  }\n\n  if ('extensionASTNodes' in entity && entity.extensionASTNodes != null) {\n    nodes = nodes.concat(entity.extensionASTNodes);\n  }\n\n  var directives;\n\n  if (directivesInExtensions != null) {\n    directives = makeDirectiveNodes(schema, directivesInExtensions);\n  } else {\n    directives = [];\n\n    var _iterator14 = _createForOfIteratorHelper(nodes),\n        _step14;\n\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var node = _step14.value;\n\n        if (node.directives) {\n          var _directives;\n\n          (_directives = directives).push.apply(_directives, _toConsumableArray(node.directives));\n        }\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n  }\n\n  return directives;\n}\n\nfunction getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  var directiveNodesBesidesDeprecated = [];\n  var deprecatedDirectiveNode = null;\n  var directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n  var directives;\n\n  if (directivesInExtensions != null) {\n    directives = makeDirectiveNodes(schema, directivesInExtensions);\n  } else {\n    directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;\n  }\n\n  if (directives != null) {\n    directiveNodesBesidesDeprecated = directives.filter(function (directive) {\n      return directive.name.value !== 'deprecated';\n    });\n\n    if (entity.deprecationReason != null) {\n      deprecatedDirectiveNode = (_b = directives.filter(function (directive) {\n        return directive.name.value === 'deprecated';\n      })) === null || _b === void 0 ? void 0 : _b[0];\n    }\n  }\n\n  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {\n    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n  }\n\n  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);\n}\n\nfunction astFromArg(arg, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  return {\n    kind: Kind.INPUT_VALUE_DEFINITION,\n    description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {\n      kind: Kind.STRING,\n      value: arg.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: arg.name\n    },\n    type: astFromType(arg.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    defaultValue: arg.defaultValue !== undefined ? (_c = astFromValue(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : undefined : undefined,\n    directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.OBJECT_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(function (field) {\n      return astFromField(field, schema, pathToDirectivesInExtensions);\n    }),\n    interfaces: Object.values(type.getInterfaces()).map(function (iFace) {\n      return astFromType(iFace);\n    }),\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  var node = {\n    kind: Kind.INTERFACE_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(function (field) {\n      return astFromField(field, schema, pathToDirectivesInExtensions);\n    }),\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n\n  if ('getInterfaces' in type) {\n    node.interfaces = Object.values(type.getInterfaces()).map(function (iFace) {\n      return astFromType(iFace);\n    });\n  }\n\n  return node;\n}\n\nfunction astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.UNION_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    types: type.getTypes().map(function (type) {\n      return astFromType(type);\n    })\n  };\n}\n\nfunction astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(function (field) {\n      return astFromInputField(field, schema, pathToDirectivesInExtensions);\n    }),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.ENUM_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    values: Object.values(type.getValues()).map(function (value) {\n      return astFromEnumValue(value, schema, pathToDirectivesInExtensions);\n    }),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  var directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n  var directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];\n\n  if (type['specifiedByUrl'] && !directives.some(function (directiveNode) {\n    return directiveNode.name.value === 'specifiedBy';\n  })) {\n    var specifiedByArgs = {\n      url: type['specifiedByUrl']\n    };\n    directives.push(makeDirectiveNode('specifiedBy', specifiedByArgs));\n  }\n\n  return {\n    kind: Kind.SCALAR_TYPE_DEFINITION,\n    description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {\n      kind: Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: directives\n  };\n}\n\nfunction astFromField(field, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.FIELD_DEFINITION,\n    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {\n      kind: Kind.STRING,\n      value: field.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: field.name\n    },\n    arguments: field.args.map(function (arg) {\n      return astFromArg(arg, schema, pathToDirectivesInExtensions);\n    }),\n    type: astFromType(field.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromInputField(field, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  return {\n    kind: Kind.INPUT_VALUE_DEFINITION,\n    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {\n      kind: Kind.STRING,\n      value: field.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: field.name\n    },\n    type: astFromType(field.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    defaultValue: (_c = astFromValue(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : undefined\n  };\n}\n\nfunction astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: Kind.ENUM_VALUE_DEFINITION,\n    description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {\n      kind: Kind.STRING,\n      value: value.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: Kind.NAME,\n      value: value.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction makeDeprecatedDirective(deprecationReason) {\n  return makeDirectiveNode('deprecated', {\n    reason: deprecationReason\n  }, GraphQLDeprecatedDirective);\n}\n\nfunction makeDirectiveNode(name, args, directive) {\n  var directiveArguments = [];\n\n  if (directive != null) {\n    var _iterator15 = _createForOfIteratorHelper(directive.args),\n        _step15;\n\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var arg = _step15.value;\n        var argName = arg.name;\n        var argValue = args[argName];\n\n        if (argValue !== undefined) {\n          var value = astFromValue(argValue, arg.type);\n\n          if (value) {\n            directiveArguments.push({\n              kind: Kind.ARGUMENT,\n              name: {\n                kind: Kind.NAME,\n                value: argName\n              },\n              value: value\n            });\n          }\n        }\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n  } else {\n    for (var _argName in args) {\n      var _argValue = args[_argName];\n\n      var _value = astFromValueUntyped(_argValue);\n\n      if (_value) {\n        directiveArguments.push({\n          kind: Kind.ARGUMENT,\n          name: {\n            kind: Kind.NAME,\n            value: _argName\n          },\n          value: _value\n        });\n      }\n    }\n  }\n\n  return {\n    kind: Kind.DIRECTIVE,\n    name: {\n      kind: Kind.NAME,\n      value: name\n    },\n    arguments: directiveArguments\n  };\n}\n\nfunction makeDirectiveNodes(schema, directiveValues) {\n  var directiveNodes = [];\n\n  for (var directiveName in directiveValues) {\n    var arrayOrSingleValue = directiveValues[directiveName];\n    var directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);\n\n    if (Array.isArray(arrayOrSingleValue)) {\n      var _iterator16 = _createForOfIteratorHelper(arrayOrSingleValue),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var value = _step16.value;\n          directiveNodes.push(makeDirectiveNode(directiveName, value, directive));\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n    } else {\n      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));\n    }\n  }\n\n  return directiveNodes;\n}\n\nvar AggregateErrorImpl = globalThis.AggregateError;\n\nif (typeof AggregateErrorImpl === 'undefined') {\n  var AggregateErrorClass = /*#__PURE__*/function (_Error) {\n    _inherits(AggregateErrorClass, _Error);\n\n    var _super = _createSuper(AggregateErrorClass);\n\n    function AggregateErrorClass(errors) {\n      var _this;\n\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      _classCallCheck(this, AggregateErrorClass);\n\n      _this = _super.call(this, message);\n      _this.errors = errors;\n      _this.name = 'AggregateError';\n      Error.captureStackTrace(_assertThisInitialized(_this), AggregateErrorClass);\n      return _this;\n    }\n\n    return AggregateErrorClass;\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n  AggregateErrorImpl = function AggregateErrorImpl(errors, message) {\n    return new AggregateErrorClass(errors, message);\n  };\n}\n\nfunction validateGraphQlDocuments(_x, _x2) {\n  return _validateGraphQlDocuments.apply(this, arguments);\n}\n\nfunction _validateGraphQlDocuments() {\n  _validateGraphQlDocuments = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(schema, documentFiles) {\n    var effectiveRules,\n        allFragmentMap,\n        documentFileObjectsToValidate,\n        _iterator49,\n        _step49,\n        documentFile,\n        definitionsToValidate,\n        _iterator50,\n        _step50,\n        definitionNode,\n        allErrors,\n        allFragmentsDocument,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            effectiveRules = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : createDefaultRules();\n            allFragmentMap = new Map();\n            documentFileObjectsToValidate = [];\n            _iterator49 = _createForOfIteratorHelper(documentFiles);\n\n            try {\n              for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {\n                documentFile = _step49.value;\n\n                if (documentFile.document) {\n                  definitionsToValidate = [];\n                  _iterator50 = _createForOfIteratorHelper(documentFile.document.definitions);\n\n                  try {\n                    for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {\n                      definitionNode = _step50.value;\n\n                      if (definitionNode.kind === Kind.FRAGMENT_DEFINITION) {\n                        allFragmentMap.set(definitionNode.name.value, definitionNode);\n                      } else {\n                        definitionsToValidate.push(definitionNode);\n                      }\n                    }\n                  } catch (err) {\n                    _iterator50.e(err);\n                  } finally {\n                    _iterator50.f();\n                  }\n\n                  documentFileObjectsToValidate.push({\n                    location: documentFile.location,\n                    document: {\n                      kind: Kind.DOCUMENT,\n                      definitions: definitionsToValidate\n                    }\n                  });\n                }\n              }\n            } catch (err) {\n              _iterator49.e(err);\n            } finally {\n              _iterator49.f();\n            }\n\n            allErrors = [];\n            allFragmentsDocument = {\n              kind: Kind.DOCUMENT,\n              definitions: _toConsumableArray(allFragmentMap.values())\n            };\n            _context2.next = 9;\n            return Promise.all(documentFileObjectsToValidate.map( /*#__PURE__*/function () {\n              var _ref50 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(documentFile) {\n                var documentToValidate, errors;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        documentToValidate = concatAST([allFragmentsDocument, documentFile.document]);\n                        errors = validate(schema, documentToValidate, effectiveRules);\n\n                        if (errors.length > 0) {\n                          allErrors.push({\n                            filePath: documentFile.location,\n                            errors: errors\n                          });\n                        }\n\n                      case 3:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function (_x3) {\n                return _ref50.apply(this, arguments);\n              };\n            }()));\n\n          case 9:\n            return _context2.abrupt(\"return\", allErrors);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _validateGraphQlDocuments.apply(this, arguments);\n}\n\nfunction checkValidationErrors(loadDocumentErrors) {\n  if (loadDocumentErrors.length > 0) {\n    var errors = [];\n\n    var _iterator17 = _createForOfIteratorHelper(loadDocumentErrors),\n        _step17;\n\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var loadDocumentError = _step17.value;\n\n        var _iterator18 = _createForOfIteratorHelper(loadDocumentError.errors),\n            _step18;\n\n        try {\n          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n            var graphQLError = _step18.value;\n            var error = new Error();\n            error.name = 'GraphQLDocumentError';\n            error.message = \"\".concat(error.name, \": \").concat(graphQLError.message);\n            error.stack = error.message;\n\n            if (graphQLError.locations) {\n              var _iterator19 = _createForOfIteratorHelper(graphQLError.locations),\n                  _step19;\n\n              try {\n                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                  var location = _step19.value;\n                  error.stack += \"\\n    at \".concat(loadDocumentError.filePath, \":\").concat(location.line, \":\").concat(location.column);\n                }\n              } catch (err) {\n                _iterator19.e(err);\n              } finally {\n                _iterator19.f();\n              }\n            }\n\n            errors.push(error);\n          }\n        } catch (err) {\n          _iterator18.e(err);\n        } finally {\n          _iterator18.f();\n        }\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n\n    throw new AggregateErrorImpl(errors, \"GraphQL Document Validation failed with \".concat(errors.length, \" errors;\\n  \").concat(errors.map(function (error, index) {\n      return \"Error \".concat(index, \": \").concat(error.stack);\n    }).join('\\n\\n')));\n  }\n}\n\nfunction createDefaultRules() {\n  var ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n\n  if (versionInfo.major < 15) {\n    ignored = ignored.map(function (rule) {\n      return rule.replace(/Rule$/, '');\n    });\n  }\n\n  return specifiedRules.filter(function (f) {\n    return !ignored.includes(f.name);\n  });\n}\n\nfunction stripBOM(content) {\n  content = content.toString(); // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n\n  if (content.charCodeAt(0) === 0xfeff) {\n    content = content.slice(1);\n  }\n\n  return content;\n}\n\nfunction parseBOM(content) {\n  return JSON.parse(stripBOM(content));\n}\n\nfunction parseGraphQLJSON(location, jsonContent, options) {\n  var parsedJson = parseBOM(jsonContent);\n\n  if (parsedJson.data) {\n    parsedJson = parsedJson.data;\n  }\n\n  if (parsedJson.kind === 'Document') {\n    return {\n      location: location,\n      document: parsedJson\n    };\n  } else if (parsedJson.__schema) {\n    var schema = buildClientSchema(parsedJson, options);\n    return {\n      location: location,\n      schema: schema\n    };\n  } else if (typeof parsedJson === 'string') {\n    return {\n      location: location,\n      rawSDL: parsedJson\n    };\n  }\n\n  throw new Error(\"Not valid JSON content\");\n}\n\nvar MAX_LINE_LENGTH = 80;\nvar commentsRegistry = {};\n\nfunction resetComments() {\n  commentsRegistry = {};\n}\n\nfunction collectComment(node) {\n  var _a;\n\n  var entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n\n  if (entityName == null) {\n    return;\n  }\n\n  pushComment(node, entityName);\n\n  switch (node.kind) {\n    case 'EnumTypeDefinition':\n      if (node.values) {\n        var _iterator20 = _createForOfIteratorHelper(node.values),\n            _step20;\n\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var value = _step20.value;\n            pushComment(value, entityName, value.name.value);\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n      }\n\n      break;\n\n    case 'ObjectTypeDefinition':\n    case 'InputObjectTypeDefinition':\n    case 'InterfaceTypeDefinition':\n      if (node.fields) {\n        var _iterator21 = _createForOfIteratorHelper(node.fields),\n            _step21;\n\n        try {\n          for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n            var field = _step21.value;\n            pushComment(field, entityName, field.name.value);\n\n            if (isFieldDefinitionNode(field) && field.arguments) {\n              var _iterator22 = _createForOfIteratorHelper(field.arguments),\n                  _step22;\n\n              try {\n                for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                  var arg = _step22.value;\n                  pushComment(arg, entityName, field.name.value, arg.name.value);\n                }\n              } catch (err) {\n                _iterator22.e(err);\n              } finally {\n                _iterator22.f();\n              }\n            }\n          }\n        } catch (err) {\n          _iterator21.e(err);\n        } finally {\n          _iterator21.f();\n        }\n      }\n\n      break;\n  }\n}\n\nfunction pushComment(node, entity, field, argument) {\n  var comment = getComment(node);\n\n  if (typeof comment !== 'string' || comment.length === 0) {\n    return;\n  }\n\n  var keys = [entity];\n\n  if (field) {\n    keys.push(field);\n\n    if (argument) {\n      keys.push(argument);\n    }\n  }\n\n  var path = keys.join('.');\n\n  if (!commentsRegistry[path]) {\n    commentsRegistry[path] = [];\n  }\n\n  commentsRegistry[path].push(comment);\n}\n\nfunction printComment(comment) {\n  return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n\nfunction hasMultilineItems(maybeArray) {\n  var _a;\n\n  return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(function (str) {\n    return str.includes('\\n');\n  })) !== null && _a !== void 0 ? _a : false;\n}\n\nfunction addDescription(cb) {\n  return function (node, _key, _parent, path, ancestors) {\n    var _a;\n\n    var keys = [];\n    var parent = path.reduce(function (prev, key) {\n      if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n        keys.push(prev.name.value);\n      }\n\n      return prev[key];\n    }, ancestors[0]);\n    var key = [].concat(keys, [(_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value]).filter(Boolean).join('.');\n    var items = [];\n\n    if (node.kind.includes('Definition') && commentsRegistry[key]) {\n      items.push.apply(items, _toConsumableArray(commentsRegistry[key]));\n    }\n\n    return join([].concat(_toConsumableArray(items.map(printComment)), [node.description, cb(node, _key, _parent, path, ancestors)]), '\\n');\n  };\n}\n\nfunction indent(maybeString) {\n  return maybeString && \"  \".concat(maybeString.replace(/\\n/g, '\\n  '));\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? \"{\\n\".concat(indent(join(array, '\\n')), \"\\n}\") : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nfunction printBlockString(value) {\n  var isDescription = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? \"\\\"\\\"\\\"\".concat(escaped.replace(/\"$/, '\"\\n'), \"\\\"\\\"\\\"\") : \"\\\"\\\"\\\"\\n\".concat(isDescription ? escaped : indent(escaped), \"\\n\\\"\\\"\\\"\");\n}\n\nvar printDocASTReducer = {\n  Name: {\n    leave: function leave(node) {\n      return node.value;\n    }\n  },\n  Variable: {\n    leave: function leave(node) {\n      return '$' + node.name;\n    }\n  },\n  // Document\n  Document: {\n    leave: function leave(node) {\n      return join(node.definitions, '\\n\\n');\n    }\n  },\n  OperationDefinition: {\n    leave: function leave(node) {\n      var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      var prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' '); // the query short form.\n\n      return prefix + ' ' + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: function leave(_ref5) {\n      var variable = _ref5.variable,\n          type = _ref5.type,\n          defaultValue = _ref5.defaultValue,\n          directives = _ref5.directives;\n      return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n    }\n  },\n  SelectionSet: {\n    leave: function leave(_ref6) {\n      var selections = _ref6.selections;\n      return block(selections);\n    }\n  },\n  Field: {\n    leave: function leave(_ref7) {\n      var alias = _ref7.alias,\n          name = _ref7.name,\n          args = _ref7.arguments,\n          directives = _ref7.directives,\n          selectionSet = _ref7.selectionSet;\n      var prefix = wrap('', alias, ': ') + name;\n      var argsLine = prefix + wrap('(', join(args, ', '), ')');\n\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  Argument: {\n    leave: function leave(_ref8) {\n      var name = _ref8.name,\n          value = _ref8.value;\n      return name + ': ' + value;\n    }\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: function leave(_ref9) {\n      var name = _ref9.name,\n          directives = _ref9.directives;\n      return '...' + name + wrap(' ', join(directives, ' '));\n    }\n  },\n  InlineFragment: {\n    leave: function leave(_ref10) {\n      var typeCondition = _ref10.typeCondition,\n          directives = _ref10.directives,\n          selectionSet = _ref10.selectionSet;\n      return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  FragmentDefinition: {\n    leave: function leave(_ref11) {\n      var name = _ref11.name,\n          typeCondition = _ref11.typeCondition,\n          variableDefinitions = _ref11.variableDefinitions,\n          directives = _ref11.directives,\n          selectionSet = _ref11.selectionSet;\n      return (// Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        \"fragment \".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap('', join(directives, ' '), ' ')) + selectionSet\n      );\n    }\n  },\n  // Value\n  IntValue: {\n    leave: function leave(_ref12) {\n      var value = _ref12.value;\n      return value;\n    }\n  },\n  FloatValue: {\n    leave: function leave(_ref13) {\n      var value = _ref13.value;\n      return value;\n    }\n  },\n  StringValue: {\n    leave: function leave(_ref14) {\n      var value = _ref14.value,\n          isBlockString = _ref14.block;\n\n      if (isBlockString) {\n        return printBlockString(value);\n      }\n\n      return JSON.stringify(value);\n    }\n  },\n  BooleanValue: {\n    leave: function leave(_ref15) {\n      var value = _ref15.value;\n      return value ? 'true' : 'false';\n    }\n  },\n  NullValue: {\n    leave: function leave() {\n      return 'null';\n    }\n  },\n  EnumValue: {\n    leave: function leave(_ref16) {\n      var value = _ref16.value;\n      return value;\n    }\n  },\n  ListValue: {\n    leave: function leave(_ref17) {\n      var values = _ref17.values;\n      return '[' + join(values, ', ') + ']';\n    }\n  },\n  ObjectValue: {\n    leave: function leave(_ref18) {\n      var fields = _ref18.fields;\n      return '{' + join(fields, ', ') + '}';\n    }\n  },\n  ObjectField: {\n    leave: function leave(_ref19) {\n      var name = _ref19.name,\n          value = _ref19.value;\n      return name + ': ' + value;\n    }\n  },\n  // Directive\n  Directive: {\n    leave: function leave(_ref20) {\n      var name = _ref20.name,\n          args = _ref20.arguments;\n      return '@' + name + wrap('(', join(args, ', '), ')');\n    }\n  },\n  // Type\n  NamedType: {\n    leave: function leave(_ref21) {\n      var name = _ref21.name;\n      return name;\n    }\n  },\n  ListType: {\n    leave: function leave(_ref22) {\n      var type = _ref22.type;\n      return '[' + type + ']';\n    }\n  },\n  NonNullType: {\n    leave: function leave(_ref23) {\n      var type = _ref23.type;\n      return type + '!';\n    }\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: function leave(_ref24) {\n      var directives = _ref24.directives,\n          operationTypes = _ref24.operationTypes;\n      return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  OperationTypeDefinition: {\n    leave: function leave(_ref25) {\n      var operation = _ref25.operation,\n          type = _ref25.type;\n      return operation + ': ' + type;\n    }\n  },\n  ScalarTypeDefinition: {\n    leave: function leave(_ref26) {\n      var name = _ref26.name,\n          directives = _ref26.directives;\n      return join(['scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeDefinition: {\n    leave: function leave(_ref27) {\n      var name = _ref27.name,\n          interfaces = _ref27.interfaces,\n          directives = _ref27.directives,\n          fields = _ref27.fields;\n      return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  FieldDefinition: {\n    leave: function leave(_ref28) {\n      var name = _ref28.name,\n          args = _ref28.arguments,\n          type = _ref28.type,\n          directives = _ref28.directives;\n      return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n    }\n  },\n  InputValueDefinition: {\n    leave: function leave(_ref29) {\n      var name = _ref29.name,\n          type = _ref29.type,\n          defaultValue = _ref29.defaultValue,\n          directives = _ref29.directives;\n      return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n    }\n  },\n  InterfaceTypeDefinition: {\n    leave: function leave(_ref30) {\n      var name = _ref30.name,\n          interfaces = _ref30.interfaces,\n          directives = _ref30.directives,\n          fields = _ref30.fields;\n      return join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeDefinition: {\n    leave: function leave(_ref31) {\n      var name = _ref31.name,\n          directives = _ref31.directives,\n          types = _ref31.types;\n      return join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeDefinition: {\n    leave: function leave(_ref32) {\n      var name = _ref32.name,\n          directives = _ref32.directives,\n          values = _ref32.values;\n      return join(['enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  EnumValueDefinition: {\n    leave: function leave(_ref33) {\n      var name = _ref33.name,\n          directives = _ref33.directives;\n      return join([name, join(directives, ' ')], ' ');\n    }\n  },\n  InputObjectTypeDefinition: {\n    leave: function leave(_ref34) {\n      var name = _ref34.name,\n          directives = _ref34.directives,\n          fields = _ref34.fields;\n      return join(['input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  DirectiveDefinition: {\n    leave: function leave(_ref35) {\n      var name = _ref35.name,\n          args = _ref35.arguments,\n          repeatable = _ref35.repeatable,\n          locations = _ref35.locations;\n      return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n    }\n  },\n  SchemaExtension: {\n    leave: function leave(_ref36) {\n      var directives = _ref36.directives,\n          operationTypes = _ref36.operationTypes;\n      return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  ScalarTypeExtension: {\n    leave: function leave(_ref37) {\n      var name = _ref37.name,\n          directives = _ref37.directives;\n      return join(['extend scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeExtension: {\n    leave: function leave(_ref38) {\n      var name = _ref38.name,\n          interfaces = _ref38.interfaces,\n          directives = _ref38.directives,\n          fields = _ref38.fields;\n      return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  InterfaceTypeExtension: {\n    leave: function leave(_ref39) {\n      var name = _ref39.name,\n          interfaces = _ref39.interfaces,\n          directives = _ref39.directives,\n          fields = _ref39.fields;\n      return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeExtension: {\n    leave: function leave(_ref40) {\n      var name = _ref40.name,\n          directives = _ref40.directives,\n          types = _ref40.types;\n      return join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeExtension: {\n    leave: function leave(_ref41) {\n      var name = _ref41.name,\n          directives = _ref41.directives,\n          values = _ref41.values;\n      return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  InputObjectTypeExtension: {\n    leave: function leave(_ref42) {\n      var name = _ref42.name,\n          directives = _ref42.directives,\n          fields = _ref42.fields;\n      return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  }\n};\nvar printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce(function (prev, key) {\n  return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, key, {\n    leave: addDescription(printDocASTReducer[key].leave)\n  }));\n}, {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nfunction printWithComments(ast) {\n  return visit(ast, printDocASTReducerWithComments);\n}\n\nfunction isFieldDefinitionNode(node) {\n  return node.kind === 'FieldDefinition';\n} // graphql < v13 and > v15 does not export getDescription\n\n\nfunction getDescription(node, options) {\n  if (node.description != null) {\n    return node.description.value;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n    return getComment(node);\n  }\n}\n\nfunction getComment(node) {\n  var rawValue = getLeadingCommentBlock(node);\n\n  if (rawValue !== undefined) {\n    return dedentBlockStringValue(\"\\n\".concat(rawValue));\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\n\nfunction getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n\n    var _indent = leadingWhitespace(line);\n\n    if (_indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || _indent < commonIndent) {\n      commonIndent = _indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\nfunction parseGraphQLSDL(location, rawSDL) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var document;\n\n  try {\n    if (options.commentDescriptions && rawSDL.includes('#')) {\n      document = transformCommentsToDescriptions(rawSDL, options); // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n      // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n      // into descriptions.\n\n      if (options.noLocation) {\n        document = parse(print(document), options);\n      }\n    } else {\n      document = parse(new Source(rawSDL, location), options);\n    }\n  } catch (e) {\n    if (e.message.includes('EOF') && rawSDL.replace(/(\\#[^*]*)/g, '').trim() === '') {\n      document = {\n        kind: Kind.DOCUMENT,\n        definitions: []\n      };\n    } else {\n      throw e;\n    }\n  }\n\n  return {\n    location: location,\n    document: document\n  };\n}\n\nfunction transformCommentsToDescriptions(sourceSdl) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var parsedDoc = parse(sourceSdl, _objectSpread(_objectSpread({}, options), {}, {\n    noLocation: false\n  }));\n  var modifiedDoc = visit(parsedDoc, {\n    leave: function leave(node) {\n      if (isDescribable(node)) {\n        var rawValue = getLeadingCommentBlock(node);\n\n        if (rawValue !== undefined) {\n          var commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n          var isBlock = commentsBlock.includes('\\n');\n\n          if (!node.description) {\n            return _objectSpread(_objectSpread({}, node), {}, {\n              description: {\n                kind: Kind.STRING,\n                value: commentsBlock,\n                block: isBlock\n              }\n            });\n          } else {\n            return _objectSpread(_objectSpread({}, node), {}, {\n              description: _objectSpread(_objectSpread({}, node.description), {}, {\n                value: node.description.value + '\\n' + commentsBlock,\n                block: true\n              })\n            });\n          }\n        }\n      }\n    }\n  });\n  return modifiedDoc;\n}\n\nfunction isDescribable(node) {\n  return isTypeSystemDefinitionNode(node) || node.kind === Kind.FIELD_DEFINITION || node.kind === Kind.INPUT_VALUE_DEFINITION || node.kind === Kind.ENUM_VALUE_DEFINITION;\n}\n\nvar operationVariables = [];\nvar fieldTypeMap = new Map();\n\nfunction addOperationVariable(variable) {\n  operationVariables.push(variable);\n}\n\nfunction resetOperationVariables() {\n  operationVariables = [];\n}\n\nfunction resetFieldMap() {\n  fieldTypeMap = new Map();\n}\n\nfunction buildOperationNodeForField(_ref43) {\n  var schema = _ref43.schema,\n      kind = _ref43.kind,\n      field = _ref43.field,\n      models = _ref43.models,\n      _ref43$ignore = _ref43.ignore,\n      ignore = _ref43$ignore === void 0 ? [] : _ref43$ignore,\n      depthLimit = _ref43.depthLimit,\n      circularReferenceDepth = _ref43.circularReferenceDepth,\n      argNames = _ref43.argNames,\n      _ref43$selectedFields = _ref43.selectedFields,\n      selectedFields = _ref43$selectedFields === void 0 ? true : _ref43$selectedFields;\n  resetOperationVariables();\n  resetFieldMap();\n  var rootTypeNames = getRootTypeNames(schema);\n  var operationNode = buildOperationAndCollectVariables({\n    schema: schema,\n    fieldName: field,\n    kind: kind,\n    models: models || [],\n    ignore: ignore,\n    depthLimit: depthLimit || Infinity,\n    circularReferenceDepth: circularReferenceDepth || 1,\n    argNames: argNames,\n    selectedFields: selectedFields,\n    rootTypeNames: rootTypeNames\n  }); // attach variables\n\n  operationNode.variableDefinitions = _toConsumableArray(operationVariables);\n  resetOperationVariables();\n  resetFieldMap();\n  return operationNode;\n}\n\nfunction buildOperationAndCollectVariables(_ref44) {\n  var schema = _ref44.schema,\n      fieldName = _ref44.fieldName,\n      kind = _ref44.kind,\n      models = _ref44.models,\n      ignore = _ref44.ignore,\n      depthLimit = _ref44.depthLimit,\n      circularReferenceDepth = _ref44.circularReferenceDepth,\n      argNames = _ref44.argNames,\n      selectedFields = _ref44.selectedFields,\n      rootTypeNames = _ref44.rootTypeNames;\n  var type = getDefinedRootType(schema, kind);\n  var field = type.getFields()[fieldName];\n  var operationName = \"\".concat(fieldName, \"_\").concat(kind);\n\n  if (field.args) {\n    var _iterator23 = _createForOfIteratorHelper(field.args),\n        _step23;\n\n    try {\n      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n        var arg = _step23.value;\n        var argName = arg.name;\n\n        if (!argNames || argNames.includes(argName)) {\n          addOperationVariable(resolveVariable(arg, argName));\n        }\n      }\n    } catch (err) {\n      _iterator23.e(err);\n    } finally {\n      _iterator23.f();\n    }\n  }\n\n  return {\n    kind: Kind.OPERATION_DEFINITION,\n    operation: kind,\n    name: {\n      kind: Kind.NAME,\n      value: operationName\n    },\n    variableDefinitions: [],\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: [resolveField({\n        type: type,\n        field: field,\n        models: models,\n        firstCall: true,\n        path: [],\n        ancestors: [],\n        ignore: ignore,\n        depthLimit: depthLimit,\n        circularReferenceDepth: circularReferenceDepth,\n        schema: schema,\n        depth: 0,\n        argNames: argNames,\n        selectedFields: selectedFields,\n        rootTypeNames: rootTypeNames\n      })]\n    }\n  };\n}\n\nfunction resolveSelectionSet(_ref45) {\n  var parent = _ref45.parent,\n      type = _ref45.type,\n      models = _ref45.models,\n      firstCall = _ref45.firstCall,\n      path = _ref45.path,\n      ancestors = _ref45.ancestors,\n      ignore = _ref45.ignore,\n      depthLimit = _ref45.depthLimit,\n      circularReferenceDepth = _ref45.circularReferenceDepth,\n      schema = _ref45.schema,\n      depth = _ref45.depth,\n      argNames = _ref45.argNames,\n      selectedFields = _ref45.selectedFields,\n      rootTypeNames = _ref45.rootTypeNames;\n\n  if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n    return;\n  }\n\n  if (isUnionType(type)) {\n    var types = type.getTypes();\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: types.filter(function (t) {\n        return !hasCircularRef([].concat(_toConsumableArray(ancestors), [t]), {\n          depth: circularReferenceDepth\n        });\n      }).map(function (t) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models: models,\n            path: path,\n            ancestors: ancestors,\n            ignore: ignore,\n            depthLimit: depthLimit,\n            circularReferenceDepth: circularReferenceDepth,\n            schema: schema,\n            depth: depth,\n            argNames: argNames,\n            selectedFields: selectedFields,\n            rootTypeNames: rootTypeNames\n          })\n        };\n      }).filter(function (fragmentNode) {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (isInterfaceType(type)) {\n    var _types = Object.values(schema.getTypeMap()).filter(function (t) {\n      return isObjectType(t) && t.getInterfaces().includes(type);\n    });\n\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: _types.filter(function (t) {\n        return !hasCircularRef([].concat(_toConsumableArray(ancestors), [t]), {\n          depth: circularReferenceDepth\n        });\n      }).map(function (t) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models: models,\n            path: path,\n            ancestors: ancestors,\n            ignore: ignore,\n            depthLimit: depthLimit,\n            circularReferenceDepth: circularReferenceDepth,\n            schema: schema,\n            depth: depth,\n            argNames: argNames,\n            selectedFields: selectedFields,\n            rootTypeNames: rootTypeNames\n          })\n        };\n      }).filter(function (fragmentNode) {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (isObjectType(type) && !rootTypeNames.has(type.name)) {\n    var isIgnored = ignore.includes(type.name) || ignore.includes(\"\".concat(parent.name, \".\").concat(path[path.length - 1]));\n    var isModel = models.includes(type.name);\n\n    if (!firstCall && isModel && !isIgnored) {\n      return {\n        kind: Kind.SELECTION_SET,\n        selections: [{\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: 'id'\n          }\n        }]\n      };\n    }\n\n    var fields = type.getFields();\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: Object.keys(fields).filter(function (fieldName) {\n        return !hasCircularRef([].concat(_toConsumableArray(ancestors), [getNamedType(fields[fieldName].type)]), {\n          depth: circularReferenceDepth\n        });\n      }).map(function (fieldName) {\n        var selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n\n        if (selectedSubFields) {\n          return resolveField({\n            type: type,\n            field: fields[fieldName],\n            models: models,\n            path: [].concat(_toConsumableArray(path), [fieldName]),\n            ancestors: ancestors,\n            ignore: ignore,\n            depthLimit: depthLimit,\n            circularReferenceDepth: circularReferenceDepth,\n            schema: schema,\n            depth: depth,\n            argNames: argNames,\n            selectedFields: selectedSubFields,\n            rootTypeNames: rootTypeNames\n          });\n        }\n\n        return null;\n      }).filter(function (f) {\n        var _a, _b;\n\n        if (f == null) {\n          return false;\n        } else if ('selectionSet' in f) {\n          return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n        }\n\n        return true;\n      })\n    };\n  }\n}\n\nfunction resolveVariable(arg, name) {\n  function resolveVariableType(type) {\n    if (isListType(type)) {\n      return {\n        kind: Kind.LIST_TYPE,\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    if (isNonNullType(type)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        // for v16 compatibility\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: {\n        kind: Kind.NAME,\n        value: type.name\n      }\n    };\n  }\n\n  return {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: name || arg.name\n      }\n    },\n    type: resolveVariableType(arg.type)\n  };\n}\n\nfunction getArgumentName(name, path) {\n  return [].concat(_toConsumableArray(path), [name]).join('_');\n}\n\nfunction resolveField(_ref46) {\n  var type = _ref46.type,\n      field = _ref46.field,\n      models = _ref46.models,\n      firstCall = _ref46.firstCall,\n      path = _ref46.path,\n      ancestors = _ref46.ancestors,\n      ignore = _ref46.ignore,\n      depthLimit = _ref46.depthLimit,\n      circularReferenceDepth = _ref46.circularReferenceDepth,\n      schema = _ref46.schema,\n      depth = _ref46.depth,\n      argNames = _ref46.argNames,\n      selectedFields = _ref46.selectedFields,\n      rootTypeNames = _ref46.rootTypeNames;\n  var namedType = getNamedType(field.type);\n  var args = [];\n  var removeField = false;\n\n  if (field.args && field.args.length) {\n    args = field.args.map(function (arg) {\n      var argumentName = getArgumentName(arg.name, path);\n\n      if (argNames && !argNames.includes(argumentName)) {\n        if (isNonNullType(arg.type)) {\n          removeField = true;\n        }\n\n        return null;\n      }\n\n      if (!firstCall) {\n        addOperationVariable(resolveVariable(arg, argumentName));\n      }\n\n      return {\n        kind: Kind.ARGUMENT,\n        name: {\n          kind: Kind.NAME,\n          value: arg.name\n        },\n        value: {\n          kind: Kind.VARIABLE,\n          name: {\n            kind: Kind.NAME,\n            value: getArgumentName(arg.name, path)\n          }\n        }\n      };\n    }).filter(Boolean);\n  }\n\n  if (removeField) {\n    return null;\n  }\n\n  var fieldPath = [].concat(_toConsumableArray(path), [field.name]);\n  var fieldPathStr = fieldPath.join('.');\n  var fieldName = field.name;\n\n  if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n    fieldName += field.type.toString().replace('!', 'NonNull');\n  }\n\n  fieldTypeMap.set(fieldPathStr, field.type.toString());\n\n  if (!isScalarType(namedType) && !isEnumType(namedType)) {\n    return _objectSpread(_objectSpread({\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        value: field.name\n      }\n    }, fieldName !== field.name && {\n      alias: {\n        kind: Kind.NAME,\n        value: fieldName\n      }\n    }), {}, {\n      selectionSet: resolveSelectionSet({\n        parent: type,\n        type: namedType,\n        models: models,\n        firstCall: firstCall,\n        path: fieldPath,\n        ancestors: [].concat(_toConsumableArray(ancestors), [type]),\n        ignore: ignore,\n        depthLimit: depthLimit,\n        circularReferenceDepth: circularReferenceDepth,\n        schema: schema,\n        depth: depth + 1,\n        argNames: argNames,\n        selectedFields: selectedFields,\n        rootTypeNames: rootTypeNames\n      }) || undefined,\n      arguments: args\n    });\n  }\n\n  return _objectSpread(_objectSpread({\n    kind: Kind.FIELD,\n    name: {\n      kind: Kind.NAME,\n      value: field.name\n    }\n  }, fieldName !== field.name && {\n    alias: {\n      kind: Kind.NAME,\n      value: fieldName\n    }\n  }), {}, {\n    arguments: args\n  });\n}\n\nfunction hasCircularRef(types) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    depth: 1\n  };\n  var type = types[types.length - 1];\n\n  if (isScalarType(type)) {\n    return false;\n  }\n\n  var size = types.filter(function (t) {\n    return t.name === type.name;\n  }).length;\n  return size > config.depth;\n}\n\nvar MapperKind;\n\n(function (MapperKind) {\n  MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n  MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n  MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n  MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n  MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n  MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n  MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n  MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n  MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n  MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n  MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n  MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n  MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n  MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n  MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n  MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n  MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n  MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n  MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n  MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n  MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n  MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n  MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n  MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n  MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\n\nfunction getObjectTypeFromTypeMap(typeMap, type) {\n  if (type) {\n    var maybeObjectType = typeMap[type.name];\n\n    if (isObjectType(maybeObjectType)) {\n      return maybeObjectType;\n    }\n  }\n}\n\nfunction createNamedStub(name, type) {\n  var constructor;\n\n  if (type === 'object') {\n    constructor = GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = GraphQLInterfaceType;\n  } else {\n    constructor = GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name: name,\n    fields: {\n      _fake: {\n        type: GraphQLString\n      }\n    }\n  });\n}\n\nfunction createStub(node, type) {\n  switch (node.kind) {\n    case Kind.LIST_TYPE:\n      return new GraphQLList(createStub(node.type, type));\n\n    case Kind.NON_NULL_TYPE:\n      return new GraphQLNonNull(createStub(node.type, type));\n\n    default:\n      if (type === 'output') {\n        return createNamedStub(node.name.value, 'object');\n      }\n\n      return createNamedStub(node.name.value, 'input');\n  }\n}\n\nfunction isNamedStub(type) {\n  if ('getFields' in type) {\n    var fields = type.getFields(); // eslint-disable-next-line no-unreachable-loop\n\n    for (var fieldName in fields) {\n      var field = fields[fieldName];\n      return field.name === '_fake';\n    }\n  }\n\n  return false;\n}\n\nfunction getBuiltInForStub(type) {\n  switch (type.name) {\n    case GraphQLInt.name:\n      return GraphQLInt;\n\n    case GraphQLFloat.name:\n      return GraphQLFloat;\n\n    case GraphQLString.name:\n      return GraphQLString;\n\n    case GraphQLBoolean.name:\n      return GraphQLBoolean;\n\n    case GraphQLID.name:\n      return GraphQLID;\n\n    default:\n      return type;\n  }\n}\n\nfunction rewireTypes(originalTypeMap, directives) {\n  var referenceTypeMap = Object.create(null);\n\n  for (var typeName in originalTypeMap) {\n    referenceTypeMap[typeName] = originalTypeMap[typeName];\n  }\n\n  var newTypeMap = Object.create(null);\n\n  for (var _typeName in referenceTypeMap) {\n    var namedType = referenceTypeMap[_typeName];\n\n    if (namedType == null || _typeName.startsWith('__')) {\n      continue;\n    }\n\n    var newName = namedType.name;\n\n    if (newName.startsWith('__')) {\n      continue;\n    }\n\n    if (newTypeMap[newName] != null) {\n      throw new Error(\"Duplicate schema type name \".concat(newName));\n    }\n\n    newTypeMap[newName] = namedType;\n  }\n\n  for (var _typeName2 in newTypeMap) {\n    newTypeMap[_typeName2] = rewireNamedType(newTypeMap[_typeName2]);\n  }\n\n  var newDirectives = directives.map(function (directive) {\n    return rewireDirective(directive);\n  });\n  return {\n    typeMap: newTypeMap,\n    directives: newDirectives\n  };\n\n  function rewireDirective(directive) {\n    if (isSpecifiedDirective(directive)) {\n      return directive;\n    }\n\n    var directiveConfig = directive.toConfig();\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new GraphQLDirective(directiveConfig);\n  }\n\n  function rewireArgs(args) {\n    var rewiredArgs = {};\n\n    for (var argName in args) {\n      var arg = args[argName];\n      var rewiredArgType = rewireType(arg.type);\n\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    }\n\n    return rewiredArgs;\n  }\n\n  function rewireNamedType(type) {\n    if (isObjectType(type)) {\n      var config = type.toConfig();\n\n      var newConfig = _objectSpread(_objectSpread({}, config), {}, {\n        fields: function fields() {\n          return rewireFields(config.fields);\n        },\n        interfaces: function interfaces() {\n          return rewireNamedTypes(config.interfaces);\n        }\n      });\n\n      return new GraphQLObjectType(newConfig);\n    } else if (isInterfaceType(type)) {\n      var _config = type.toConfig();\n\n      var _newConfig = _objectSpread(_objectSpread({}, _config), {}, {\n        fields: function fields() {\n          return rewireFields(_config.fields);\n        }\n      });\n\n      if ('interfaces' in _newConfig) {\n        _newConfig.interfaces = function () {\n          return rewireNamedTypes(_config.interfaces);\n        };\n      }\n\n      return new GraphQLInterfaceType(_newConfig);\n    } else if (isUnionType(type)) {\n      var _config2 = type.toConfig();\n\n      var _newConfig2 = _objectSpread(_objectSpread({}, _config2), {}, {\n        types: function types() {\n          return rewireNamedTypes(_config2.types);\n        }\n      });\n\n      return new GraphQLUnionType(_newConfig2);\n    } else if (isInputObjectType(type)) {\n      var _config3 = type.toConfig();\n\n      var _newConfig3 = _objectSpread(_objectSpread({}, _config3), {}, {\n        fields: function fields() {\n          return rewireInputFields(_config3.fields);\n        }\n      });\n\n      return new GraphQLInputObjectType(_newConfig3);\n    } else if (isEnumType(type)) {\n      var enumConfig = type.toConfig();\n      return new GraphQLEnumType(enumConfig);\n    } else if (isScalarType(type)) {\n      if (isSpecifiedScalarType(type)) {\n        return type;\n      }\n\n      var scalarConfig = type.toConfig();\n      return new GraphQLScalarType(scalarConfig);\n    }\n\n    throw new Error(\"Unexpected schema type: \".concat(type));\n  }\n\n  function rewireFields(fields) {\n    var rewiredFields = {};\n\n    for (var fieldName in fields) {\n      var field = fields[fieldName];\n      var rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null && field.args) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    }\n\n    return rewiredFields;\n  }\n\n  function rewireInputFields(fields) {\n    var rewiredFields = {};\n\n    for (var fieldName in fields) {\n      var field = fields[fieldName];\n      var rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    }\n\n    return rewiredFields;\n  }\n\n  function rewireNamedTypes(namedTypes) {\n    var rewiredTypes = [];\n\n    var _iterator24 = _createForOfIteratorHelper(namedTypes),\n        _step24;\n\n    try {\n      for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n        var _namedType = _step24.value;\n        var rewiredType = rewireType(_namedType);\n\n        if (rewiredType != null) {\n          rewiredTypes.push(rewiredType);\n        }\n      }\n    } catch (err) {\n      _iterator24.e(err);\n    } finally {\n      _iterator24.f();\n    }\n\n    return rewiredTypes;\n  }\n\n  function rewireType(type) {\n    if (isListType(type)) {\n      var rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new GraphQLList(rewiredType) : null;\n    } else if (isNonNullType(type)) {\n      var _rewiredType = rewireType(type.ofType);\n\n      return _rewiredType != null ? new GraphQLNonNull(_rewiredType) : null;\n    } else if (isNamedType(type)) {\n      var _rewiredType2 = referenceTypeMap[type.name];\n\n      if (_rewiredType2 === undefined) {\n        _rewiredType2 = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n        newTypeMap[_rewiredType2.name] = referenceTypeMap[type.name] = _rewiredType2;\n      }\n\n      return _rewiredType2 != null ? newTypeMap[_rewiredType2.name] : null;\n    }\n\n    return null;\n  }\n}\n\nfunction transformInputValue(type, value) {\n  var inputLeafValueTransformer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var inputObjectValueTransformer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  if (value == null) {\n    return value;\n  }\n\n  var nullableType = getNullableType(type);\n\n  if (isLeafType(nullableType)) {\n    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;\n  } else if (isListType(nullableType)) {\n    return value.map(function (listMember) {\n      return transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer);\n    });\n  } else if (isInputObjectType(nullableType)) {\n    var fields = nullableType.getFields();\n    var newValue = {};\n\n    for (var key in value) {\n      var field = fields[key];\n\n      if (field != null) {\n        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n      }\n    }\n\n    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;\n  } // unreachable, no other possible return value\n\n}\n\nfunction serializeInputValue(type, value) {\n  return transformInputValue(type, value, function (t, v) {\n    return t.serialize(v);\n  });\n}\n\nfunction parseInputValue(type, value) {\n  return transformInputValue(type, value, function (t, v) {\n    return t.parseValue(v);\n  });\n}\n\nfunction parseInputValueLiteral(type, value) {\n  return transformInputValue(type, value, function (t, v) {\n    return t.parseLiteral(v, {});\n  });\n}\n\nfunction mapSchema(schema) {\n  var schemaMapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, function (type) {\n    return isLeafType(type);\n  }), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, function (type) {\n    return !isLeafType(type);\n  }), schema, schemaMapper), schema, schemaMapper);\n  var originalDirectives = schema.getDirectives();\n  var newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n\n  var _rewireTypes = rewireTypes(newTypeMap, newDirectives),\n      typeMap = _rewireTypes.typeMap,\n      directives = _rewireTypes.directives;\n\n  return new GraphQLSchema(_objectSpread(_objectSpread({}, schema.toConfig()), {}, {\n    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n    types: Object.values(typeMap),\n    directives: directives\n  }));\n}\n\nfunction mapTypes(originalTypeMap, schema, schemaMapper) {\n  var testFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {\n    return true;\n  };\n  var newTypeMap = {};\n\n  for (var typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      var originalType = originalTypeMap[typeName];\n\n      if (originalType == null || !testFn(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      var typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n\n      if (typeMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      var maybeNewType = typeMapper(originalType, schema);\n\n      if (maybeNewType === undefined) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      newTypeMap[typeName] = maybeNewType;\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n  var enumValueMapper = getEnumValueMapper(schemaMapper);\n\n  if (!enumValueMapper) {\n    return originalTypeMap;\n  }\n\n  return mapTypes(originalTypeMap, schema, _defineProperty({}, MapperKind.ENUM_TYPE, function (type) {\n    var config = type.toConfig();\n    var originalEnumValueConfigMap = config.values;\n    var newEnumValueConfigMap = {};\n\n    for (var externalValue in originalEnumValueConfigMap) {\n      var originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n      var mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n\n      if (mappedEnumValue === undefined) {\n        newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n      } else if (Array.isArray(mappedEnumValue)) {\n        var _mappedEnumValue = _slicedToArray(mappedEnumValue, 2),\n            newExternalValue = _mappedEnumValue[0],\n            newEnumValueConfig = _mappedEnumValue[1];\n\n        newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n      } else if (mappedEnumValue !== null) {\n        newEnumValueConfigMap[externalValue] = mappedEnumValue;\n      }\n    }\n\n    return correctASTNodes(new GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {\n      values: newEnumValueConfigMap\n    })));\n  }), function (type) {\n    return isEnumType(type);\n  });\n}\n\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n  var newTypeMap = mapArguments(originalTypeMap, schema, _defineProperty({}, MapperKind.ARGUMENT, function (argumentConfig) {\n    if (argumentConfig.defaultValue === undefined) {\n      return argumentConfig;\n    }\n\n    var maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n\n    if (maybeNewType != null) {\n      return _objectSpread(_objectSpread({}, argumentConfig), {}, {\n        defaultValue: fn(maybeNewType, argumentConfig.defaultValue)\n      });\n    }\n  }));\n  return mapFields(newTypeMap, schema, _defineProperty({}, MapperKind.INPUT_OBJECT_FIELD, function (inputFieldConfig) {\n    if (inputFieldConfig.defaultValue === undefined) {\n      return inputFieldConfig;\n    }\n\n    var maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n\n    if (maybeNewType != null) {\n      return _objectSpread(_objectSpread({}, inputFieldConfig), {}, {\n        defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)\n      });\n    }\n  }));\n}\n\nfunction getNewType(newTypeMap, type) {\n  if (isListType(type)) {\n    var newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new GraphQLList(newType) : null;\n  } else if (isNonNullType(type)) {\n    var _newType = getNewType(newTypeMap, type.ofType);\n\n    return _newType != null ? new GraphQLNonNull(_newType) : null;\n  } else if (isNamedType(type)) {\n    var _newType2 = newTypeMap[type.name];\n    return _newType2 != null ? _newType2 : null;\n  }\n\n  return null;\n}\n\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n  var newTypeMap = {};\n\n  for (var typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      var originalType = originalTypeMap[typeName];\n\n      if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      var fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n\n      if (fieldMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      var config = originalType.toConfig();\n      var originalFieldConfigMap = config.fields;\n      var newFieldConfigMap = {};\n\n      for (var fieldName in originalFieldConfigMap) {\n        var originalFieldConfig = originalFieldConfigMap[fieldName];\n        var mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n\n        if (mappedField === undefined) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        } else if (Array.isArray(mappedField)) {\n          var _mappedField = _slicedToArray(mappedField, 2),\n              newFieldName = _mappedField[0],\n              newFieldConfig = _mappedField[1];\n\n          if (newFieldConfig.astNode != null) {\n            newFieldConfig.astNode = _objectSpread(_objectSpread({}, newFieldConfig.astNode), {}, {\n              name: _objectSpread(_objectSpread({}, newFieldConfig.astNode.name), {}, {\n                value: newFieldName\n              })\n            });\n          }\n\n          newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n        } else if (mappedField !== null) {\n          newFieldConfigMap[fieldName] = mappedField;\n        }\n      }\n\n      if (isObjectType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n          fields: newFieldConfigMap\n        })));\n      } else if (isInterfaceType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n          fields: newFieldConfigMap\n        })));\n      } else {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n          fields: newFieldConfigMap\n        })));\n      }\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n  var newTypeMap = {};\n\n  for (var typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      var originalType = originalTypeMap[typeName];\n\n      if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      var argumentMapper = getArgumentMapper(schemaMapper);\n\n      if (argumentMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      var config = originalType.toConfig();\n      var originalFieldConfigMap = config.fields;\n      var newFieldConfigMap = {};\n\n      for (var fieldName in originalFieldConfigMap) {\n        var originalFieldConfig = originalFieldConfigMap[fieldName];\n        var originalArgumentConfigMap = originalFieldConfig.args;\n\n        if (originalArgumentConfigMap == null) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n\n        var argumentNames = Object.keys(originalArgumentConfigMap);\n\n        if (!argumentNames.length) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n\n        var newArgumentConfigMap = {};\n\n        for (var _i3 = 0, _argumentNames = argumentNames; _i3 < _argumentNames.length; _i3++) {\n          var argumentName = _argumentNames[_i3];\n          var originalArgumentConfig = originalArgumentConfigMap[argumentName];\n          var mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n\n          if (mappedArgument === undefined) {\n            newArgumentConfigMap[argumentName] = originalArgumentConfig;\n          } else if (Array.isArray(mappedArgument)) {\n            var _mappedArgument = _slicedToArray(mappedArgument, 2),\n                newArgumentName = _mappedArgument[0],\n                newArgumentConfig = _mappedArgument[1];\n\n            newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n          } else if (mappedArgument !== null) {\n            newArgumentConfigMap[argumentName] = mappedArgument;\n          }\n        }\n\n        newFieldConfigMap[fieldName] = _objectSpread(_objectSpread({}, originalFieldConfig), {}, {\n          args: newArgumentConfigMap\n        });\n      }\n\n      if (isObjectType(originalType)) {\n        newTypeMap[typeName] = new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n          fields: newFieldConfigMap\n        }));\n      } else if (isInterfaceType(originalType)) {\n        newTypeMap[typeName] = new GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n          fields: newFieldConfigMap\n        }));\n      } else {\n        newTypeMap[typeName] = new GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n  var directiveMapper = getDirectiveMapper(schemaMapper);\n\n  if (directiveMapper == null) {\n    return originalDirectives.slice();\n  }\n\n  var newDirectives = [];\n\n  var _iterator25 = _createForOfIteratorHelper(originalDirectives),\n      _step25;\n\n  try {\n    for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n      var directive = _step25.value;\n      var mappedDirective = directiveMapper(directive, schema);\n\n      if (mappedDirective === undefined) {\n        newDirectives.push(directive);\n      } else if (mappedDirective !== null) {\n        newDirectives.push(mappedDirective);\n      }\n    }\n  } catch (err) {\n    _iterator25.e(err);\n  } finally {\n    _iterator25.f();\n  }\n\n  return newDirectives;\n}\n\nfunction getTypeSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n\n  var type = schema.getType(typeName);\n  var specifiers = [MapperKind.TYPE];\n\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n    }\n  } else if (isInputObjectType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n  } else if (isUnionType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n  } else if (isEnumType(type)) {\n    specifiers.push(MapperKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(MapperKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n  var specifiers = getTypeSpecifiers(schema, typeName);\n  var typeMapper;\n\n  var stack = _toConsumableArray(specifiers);\n\n  while (!typeMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    var next = stack.pop();\n    typeMapper = schemaMapper[next];\n  }\n\n  return typeMapper != null ? typeMapper : null;\n}\n\nfunction getFieldSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n\n  var type = schema.getType(typeName);\n  var specifiers = [MapperKind.FIELD];\n\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n    }\n  } else if (isInterfaceType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n  } else if (isInputObjectType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n  }\n\n  return specifiers;\n}\n\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n  var specifiers = getFieldSpecifiers(schema, typeName);\n  var fieldMapper;\n\n  var stack = _toConsumableArray(specifiers);\n\n  while (!fieldMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    var next = stack.pop(); // TODO: fix this as unknown cast\n\n    fieldMapper = schemaMapper[next];\n  }\n\n  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\n\nfunction getArgumentMapper(schemaMapper) {\n  var argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n  return argumentMapper != null ? argumentMapper : null;\n}\n\nfunction getDirectiveMapper(schemaMapper) {\n  var directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n  return directiveMapper != null ? directiveMapper : null;\n}\n\nfunction getEnumValueMapper(schemaMapper) {\n  var enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n  return enumValueMapper != null ? enumValueMapper : null;\n}\n\nfunction correctASTNodes(type) {\n  if (isObjectType(type)) {\n    var config = type.toConfig();\n\n    if (config.astNode != null) {\n      var fields = [];\n\n      for (var fieldName in config.fields) {\n        var fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = _objectSpread(_objectSpread({}, config.astNode), {}, {\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        fields: fields\n      });\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          kind: Kind.OBJECT_TYPE_EXTENSION,\n          fields: undefined\n        });\n      });\n    }\n\n    return new GraphQLObjectType(config);\n  } else if (isInterfaceType(type)) {\n    var _config4 = type.toConfig();\n\n    if (_config4.astNode != null) {\n      var _fields = [];\n\n      for (var _fieldName in _config4.fields) {\n        var _fieldConfig = _config4.fields[_fieldName];\n\n        if (_fieldConfig.astNode != null) {\n          _fields.push(_fieldConfig.astNode);\n        }\n      }\n\n      _config4.astNode = _objectSpread(_objectSpread({}, _config4.astNode), {}, {\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        fields: _fields\n      });\n    }\n\n    if (_config4.extensionASTNodes != null) {\n      _config4.extensionASTNodes = _config4.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          kind: Kind.INTERFACE_TYPE_EXTENSION,\n          fields: undefined\n        });\n      });\n    }\n\n    return new GraphQLInterfaceType(_config4);\n  } else if (isInputObjectType(type)) {\n    var _config5 = type.toConfig();\n\n    if (_config5.astNode != null) {\n      var _fields2 = [];\n\n      for (var _fieldName2 in _config5.fields) {\n        var _fieldConfig2 = _config5.fields[_fieldName2];\n\n        if (_fieldConfig2.astNode != null) {\n          _fields2.push(_fieldConfig2.astNode);\n        }\n      }\n\n      _config5.astNode = _objectSpread(_objectSpread({}, _config5.astNode), {}, {\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        fields: _fields2\n      });\n    }\n\n    if (_config5.extensionASTNodes != null) {\n      _config5.extensionASTNodes = _config5.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n          fields: undefined\n        });\n      });\n    }\n\n    return new GraphQLInputObjectType(_config5);\n  } else if (isEnumType(type)) {\n    var _config6 = type.toConfig();\n\n    if (_config6.astNode != null) {\n      var values = [];\n\n      for (var enumKey in _config6.values) {\n        var enumValueConfig = _config6.values[enumKey];\n\n        if (enumValueConfig.astNode != null) {\n          values.push(enumValueConfig.astNode);\n        }\n      }\n\n      _config6.astNode = _objectSpread(_objectSpread({}, _config6.astNode), {}, {\n        values: values\n      });\n    }\n\n    if (_config6.extensionASTNodes != null) {\n      _config6.extensionASTNodes = _config6.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          values: undefined\n        });\n      });\n    }\n\n    return new GraphQLEnumType(_config6);\n  } else {\n    return type;\n  }\n}\n\nfunction filterSchema(_ref47) {\n  var _mapSchema;\n\n  var schema = _ref47.schema,\n      _ref47$typeFilter = _ref47.typeFilter,\n      typeFilter = _ref47$typeFilter === void 0 ? function () {\n    return true;\n  } : _ref47$typeFilter,\n      _ref47$fieldFilter = _ref47.fieldFilter,\n      fieldFilter = _ref47$fieldFilter === void 0 ? undefined : _ref47$fieldFilter,\n      _ref47$rootFieldFilte = _ref47.rootFieldFilter,\n      rootFieldFilter = _ref47$rootFieldFilte === void 0 ? undefined : _ref47$rootFieldFilte,\n      _ref47$objectFieldFil = _ref47.objectFieldFilter,\n      objectFieldFilter = _ref47$objectFieldFil === void 0 ? undefined : _ref47$objectFieldFil,\n      _ref47$interfaceField = _ref47.interfaceFieldFilter,\n      interfaceFieldFilter = _ref47$interfaceField === void 0 ? undefined : _ref47$interfaceField,\n      _ref47$inputObjectFie = _ref47.inputObjectFieldFilter,\n      inputObjectFieldFilter = _ref47$inputObjectFie === void 0 ? undefined : _ref47$inputObjectFie,\n      _ref47$argumentFilter = _ref47.argumentFilter,\n      argumentFilter = _ref47$argumentFilter === void 0 ? undefined : _ref47$argumentFilter;\n  var filteredSchema = mapSchema(schema, (_mapSchema = {}, _defineProperty(_mapSchema, MapperKind.QUERY, function (type) {\n    return filterRootFields(type, 'Query', rootFieldFilter, argumentFilter);\n  }), _defineProperty(_mapSchema, MapperKind.MUTATION, function (type) {\n    return filterRootFields(type, 'Mutation', rootFieldFilter, argumentFilter);\n  }), _defineProperty(_mapSchema, MapperKind.SUBSCRIPTION, function (type) {\n    return filterRootFields(type, 'Subscription', rootFieldFilter, argumentFilter);\n  }), _defineProperty(_mapSchema, MapperKind.OBJECT_TYPE, function (type) {\n    return typeFilter(type.name, type) ? filterElementFields(GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null;\n  }), _defineProperty(_mapSchema, MapperKind.INTERFACE_TYPE, function (type) {\n    return typeFilter(type.name, type) ? filterElementFields(GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null;\n  }), _defineProperty(_mapSchema, MapperKind.INPUT_OBJECT_TYPE, function (type) {\n    return typeFilter(type.name, type) ? filterElementFields(GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null;\n  }), _defineProperty(_mapSchema, MapperKind.UNION_TYPE, function (type) {\n    return typeFilter(type.name, type) ? undefined : null;\n  }), _defineProperty(_mapSchema, MapperKind.ENUM_TYPE, function (type) {\n    return typeFilter(type.name, type) ? undefined : null;\n  }), _defineProperty(_mapSchema, MapperKind.SCALAR_TYPE, function (type) {\n    return typeFilter(type.name, type) ? undefined : null;\n  }), _mapSchema));\n  return filteredSchema;\n}\n\nfunction filterRootFields(type, operation, rootFieldFilter, argumentFilter) {\n  if (rootFieldFilter || argumentFilter) {\n    var config = type.toConfig();\n\n    for (var fieldName in config.fields) {\n      var field = config.fields[fieldName];\n\n      if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n        delete config.fields[fieldName];\n      } else if (argumentFilter && field.args) {\n        for (var argName in field.args) {\n          if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {\n            delete field.args[argName];\n          }\n        }\n      }\n    }\n\n    return new GraphQLObjectType(config);\n  }\n\n  return type;\n}\n\nfunction filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {\n  if (fieldFilter || argumentFilter) {\n    var config = type.toConfig();\n\n    for (var fieldName in config.fields) {\n      var field = config.fields[fieldName];\n\n      if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n        delete config.fields[fieldName];\n      } else if (argumentFilter && 'args' in field) {\n        for (var argName in field.args) {\n          if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {\n            delete field.args[argName];\n          }\n        }\n      }\n    }\n\n    return new ElementConstructor(config);\n  }\n} // Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\n\n\nfunction healSchema(schema) {\n  healTypes(schema.getTypeMap(), schema.getDirectives());\n  return schema;\n}\n\nfunction healTypes(originalTypeMap, directives) {\n  var actualNamedTypeMap = Object.create(null); // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n\n  for (var typeName in originalTypeMap) {\n    var namedType = originalTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      continue;\n    }\n\n    var actualName = namedType.name;\n\n    if (actualName.startsWith('__')) {\n      continue;\n    }\n\n    if (actualName in actualNamedTypeMap) {\n      throw new Error(\"Duplicate schema type name \".concat(actualName));\n    }\n\n    actualNamedTypeMap[actualName] = namedType; // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  } // Now add back every named type by its actual name.\n\n\n  for (var _typeName3 in actualNamedTypeMap) {\n    var _namedType2 = actualNamedTypeMap[_typeName3];\n    originalTypeMap[_typeName3] = _namedType2;\n  } // Directive declaration argument types can refer to named types.\n\n\n  var _iterator26 = _createForOfIteratorHelper(directives),\n      _step26;\n\n  try {\n    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n      var decl = _step26.value;\n      decl.args = decl.args.filter(function (arg) {\n        arg.type = healType(arg.type);\n        return arg.type !== null;\n      });\n    }\n  } catch (err) {\n    _iterator26.e(err);\n  } finally {\n    _iterator26.f();\n  }\n\n  for (var _typeName4 in originalTypeMap) {\n    var _namedType3 = originalTypeMap[_typeName4]; // Heal all named types, except for dangling references, kept only to redirect.\n\n    if (!_typeName4.startsWith('__') && _typeName4 in actualNamedTypeMap) {\n      if (_namedType3 != null) {\n        healNamedType(_namedType3);\n      }\n    }\n  }\n\n  for (var _typeName5 in originalTypeMap) {\n    if (!_typeName5.startsWith('__') && !(_typeName5 in actualNamedTypeMap)) {\n      delete originalTypeMap[_typeName5];\n    }\n  }\n\n  function healNamedType(type) {\n    if (isObjectType(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if (isInterfaceType(type)) {\n      healFields(type);\n\n      if ('getInterfaces' in type) {\n        healInterfaces(type);\n      }\n\n      return;\n    } else if (isUnionType(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if (isInputObjectType(type)) {\n      healInputFields(type);\n      return;\n    } else if (isLeafType(type)) {\n      return;\n    }\n\n    throw new Error(\"Unexpected schema type: \".concat(type));\n  }\n\n  function healFields(type) {\n    var fieldMap = type.getFields();\n\n    for (var _i4 = 0, _Object$entries2 = Object.entries(fieldMap); _i4 < _Object$entries2.length; _i4++) {\n      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),\n          key = _Object$entries2$_i[0],\n          field = _Object$entries2$_i[1];\n\n      field.args.map(function (arg) {\n        arg.type = healType(arg.type);\n        return arg.type === null ? null : arg;\n      }).filter(Boolean);\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healInterfaces(type) {\n    if ('getInterfaces' in type) {\n      var interfaces = type.getInterfaces();\n      interfaces.push.apply(interfaces, _toConsumableArray(interfaces.splice(0).map(function (iface) {\n        return healType(iface);\n      }).filter(Boolean)));\n    }\n  }\n\n  function healInputFields(type) {\n    var fieldMap = type.getFields();\n\n    for (var _i5 = 0, _Object$entries3 = Object.entries(fieldMap); _i5 < _Object$entries3.length; _i5++) {\n      var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i5], 2),\n          key = _Object$entries3$_i[0],\n          field = _Object$entries3$_i[1];\n\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healUnderlyingTypes(type) {\n    var types = type.getTypes();\n    types.push.apply(types, _toConsumableArray(types.splice(0).map(function (t) {\n      return healType(t);\n    }).filter(Boolean)));\n  }\n\n  function healType(type) {\n    // Unwrap the two known wrapper types\n    if (isListType(type)) {\n      var healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLList(healedType) : null;\n    } else if (isNonNullType(type)) {\n      var _healedType = healType(type.ofType);\n\n      return _healedType != null ? new GraphQLNonNull(_healedType) : null;\n    } else if (isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      var officialType = originalTypeMap[type.name];\n\n      if (officialType && type !== officialType) {\n        return officialType;\n      }\n    }\n\n    return type;\n  }\n}\n\nfunction getResolversFromSchema(schema) {\n  var _a, _b;\n\n  var resolvers = Object.create(null);\n  var typeMap = schema.getTypeMap();\n\n  for (var typeName in typeMap) {\n    if (!typeName.startsWith('__')) {\n      var type = typeMap[typeName];\n\n      if (isScalarType(type)) {\n        if (!isSpecifiedScalarType(type)) {\n          var config = type.toConfig();\n          delete config.astNode; // avoid AST duplication elsewhere\n\n          resolvers[typeName] = new GraphQLScalarType(config);\n        }\n      } else if (isEnumType(type)) {\n        resolvers[typeName] = {};\n        var values = type.getValues();\n\n        var _iterator27 = _createForOfIteratorHelper(values),\n            _step27;\n\n        try {\n          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n            var value = _step27.value;\n            resolvers[typeName][value.name] = value.value;\n          }\n        } catch (err) {\n          _iterator27.e(err);\n        } finally {\n          _iterator27.f();\n        }\n      } else if (isInterfaceType(type)) {\n        if (type.resolveType != null) {\n          resolvers[typeName] = {\n            __resolveType: type.resolveType\n          };\n        }\n      } else if (isUnionType(type)) {\n        if (type.resolveType != null) {\n          resolvers[typeName] = {\n            __resolveType: type.resolveType\n          };\n        }\n      } else if (isObjectType(type)) {\n        resolvers[typeName] = {};\n\n        if (type.isTypeOf != null) {\n          resolvers[typeName].__isTypeOf = type.isTypeOf;\n        }\n\n        var fields = type.getFields();\n\n        for (var fieldName in fields) {\n          var field = fields[fieldName];\n\n          if (field.subscribe != null) {\n            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n            resolvers[typeName][fieldName].subscribe = field.subscribe;\n          }\n\n          if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== 'defaultFieldResolver' && ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) !== 'defaultMergedResolver') {\n            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n            resolvers[typeName][fieldName].resolve = field.resolve;\n          }\n        }\n      }\n    }\n  }\n\n  return resolvers;\n}\n\nfunction forEachField(schema, fn) {\n  var typeMap = schema.getTypeMap();\n\n  for (var typeName in typeMap) {\n    var type = typeMap[typeName]; // TODO: maybe have an option to include these?\n\n    if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n      var fields = type.getFields();\n\n      for (var fieldName in fields) {\n        var field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      }\n    }\n  }\n}\n\nfunction forEachDefaultValue(schema, fn) {\n  var typeMap = schema.getTypeMap();\n\n  for (var typeName in typeMap) {\n    var type = typeMap[typeName];\n\n    if (!getNamedType(type).name.startsWith('__')) {\n      if (isObjectType(type)) {\n        var fields = type.getFields();\n\n        for (var fieldName in fields) {\n          var field = fields[fieldName];\n\n          var _iterator28 = _createForOfIteratorHelper(field.args),\n              _step28;\n\n          try {\n            for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n              var arg = _step28.value;\n              arg.defaultValue = fn(arg.type, arg.defaultValue);\n            }\n          } catch (err) {\n            _iterator28.e(err);\n          } finally {\n            _iterator28.f();\n          }\n        }\n      } else if (isInputObjectType(type)) {\n        var _fields3 = type.getFields();\n\n        for (var _fieldName3 in _fields3) {\n          var _field = _fields3[_fieldName3];\n          _field.defaultValue = fn(_field.type, _field.defaultValue);\n        }\n      }\n    }\n  }\n} // addTypes uses toConfig to create a new schema with a new or replaced\n\n\nfunction addTypes(schema, newTypesOrDirectives) {\n  var config = schema.toConfig();\n  var originalTypeMap = {};\n\n  var _iterator29 = _createForOfIteratorHelper(config.types),\n      _step29;\n\n  try {\n    for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n      var type = _step29.value;\n      originalTypeMap[type.name] = type;\n    }\n  } catch (err) {\n    _iterator29.e(err);\n  } finally {\n    _iterator29.f();\n  }\n\n  var originalDirectiveMap = {};\n\n  var _iterator30 = _createForOfIteratorHelper(config.directives),\n      _step30;\n\n  try {\n    for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n      var directive = _step30.value;\n      originalDirectiveMap[directive.name] = directive;\n    }\n  } catch (err) {\n    _iterator30.e(err);\n  } finally {\n    _iterator30.f();\n  }\n\n  var _iterator31 = _createForOfIteratorHelper(newTypesOrDirectives),\n      _step31;\n\n  try {\n    for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n      var newTypeOrDirective = _step31.value;\n\n      if (isNamedType(newTypeOrDirective)) {\n        originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n      } else if (isDirective(newTypeOrDirective)) {\n        originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n      }\n    }\n  } catch (err) {\n    _iterator31.e(err);\n  } finally {\n    _iterator31.f();\n  }\n\n  var _rewireTypes2 = rewireTypes(originalTypeMap, Object.values(originalDirectiveMap)),\n      typeMap = _rewireTypes2.typeMap,\n      directives = _rewireTypes2.directives;\n\n  return new GraphQLSchema(_objectSpread(_objectSpread({}, config), {}, {\n    query: getObjectTypeFromTypeMap(typeMap, schema.getQueryType()),\n    mutation: getObjectTypeFromTypeMap(typeMap, schema.getMutationType()),\n    subscription: getObjectTypeFromTypeMap(typeMap, schema.getSubscriptionType()),\n    types: Object.values(typeMap),\n    directives: directives\n  }));\n}\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\n\n\nfunction pruneSchema(schema) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var pruningContext = {\n    schema: schema,\n    unusedTypes: Object.create(null),\n    implementations: Object.create(null)\n  };\n\n  for (var typeName in schema.getTypeMap()) {\n    var type = schema.getType(typeName);\n\n    if (type && 'getInterfaces' in type) {\n      var _iterator32 = _createForOfIteratorHelper(type.getInterfaces()),\n          _step32;\n\n      try {\n        for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n          var iface = _step32.value;\n          var implementations = getImplementations(pruningContext, iface);\n\n          if (implementations == null) {\n            pruningContext.implementations[iface.name] = Object.create(null);\n          }\n\n          pruningContext.implementations[iface.name][type.name] = true;\n        }\n      } catch (err) {\n        _iterator32.e(err);\n      } finally {\n        _iterator32.f();\n      }\n    }\n  }\n\n  visitTypes(pruningContext, schema);\n  return mapSchema(schema, _defineProperty({}, MapperKind.TYPE, function (type) {\n    // If we should NOT prune the type, return it immediately as unmodified\n    if (options.skipPruning && options.skipPruning(type)) {\n      return type;\n    }\n\n    if (isObjectType(type) || isInputObjectType(type)) {\n      if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n        return null;\n      }\n    } else if (isUnionType(type)) {\n      if (!type.getTypes().length && !options.skipEmptyUnionPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n        return null;\n      }\n    } else if (isInterfaceType(type)) {\n      var _implementations = getImplementations(pruningContext, type);\n\n      if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || _implementations && !Object.keys(_implementations).length && !options.skipUnimplementedInterfacesPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n        return null;\n      }\n    } else {\n      if (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n        return null;\n      }\n    }\n  }));\n}\n\nfunction visitOutputType(visitedTypes, pruningContext, type) {\n  if (visitedTypes[type.name]) {\n    return;\n  }\n\n  visitedTypes[type.name] = true;\n  pruningContext.unusedTypes[type.name] = false;\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var fields = type.getFields();\n\n    for (var fieldName in fields) {\n      var field = fields[fieldName];\n      var namedType = getNamedType(field.type);\n      visitOutputType(visitedTypes, pruningContext, namedType);\n\n      var _iterator33 = _createForOfIteratorHelper(field.args),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var arg = _step33.value;\n\n          var _type = getNamedType(arg.type);\n\n          visitInputType(visitedTypes, pruningContext, _type);\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n    }\n\n    if (isInterfaceType(type)) {\n      var implementations = getImplementations(pruningContext, type);\n\n      if (implementations) {\n        for (var typeName in implementations) {\n          visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));\n        }\n      }\n    }\n\n    if ('getInterfaces' in type) {\n      var _iterator34 = _createForOfIteratorHelper(type.getInterfaces()),\n          _step34;\n\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var iFace = _step34.value;\n          visitOutputType(visitedTypes, pruningContext, iFace);\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n    }\n  } else if (isUnionType(type)) {\n    var types = type.getTypes();\n\n    var _iterator35 = _createForOfIteratorHelper(types),\n        _step35;\n\n    try {\n      for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n        var _type2 = _step35.value;\n        visitOutputType(visitedTypes, pruningContext, _type2);\n      }\n    } catch (err) {\n      _iterator35.e(err);\n    } finally {\n      _iterator35.f();\n    }\n  }\n}\n/**\n * Get the implementations of an interface. May return undefined.\n */\n\n\nfunction getImplementations(pruningContext, type) {\n  return pruningContext.implementations[type.name];\n}\n\nfunction visitInputType(visitedTypes, pruningContext, type) {\n  if (visitedTypes[type.name]) {\n    return;\n  }\n\n  pruningContext.unusedTypes[type.name] = false;\n  visitedTypes[type.name] = true;\n\n  if (isInputObjectType(type)) {\n    var fields = type.getFields();\n\n    for (var fieldName in fields) {\n      var field = fields[fieldName];\n      var namedType = getNamedType(field.type);\n      visitInputType(visitedTypes, pruningContext, namedType);\n    }\n  }\n}\n\nfunction visitTypes(pruningContext, schema) {\n  for (var typeName in schema.getTypeMap()) {\n    if (!typeName.startsWith('__')) {\n      pruningContext.unusedTypes[typeName] = true;\n    }\n  }\n\n  var visitedTypes = Object.create(null);\n  var rootTypes = getRootTypes(schema);\n\n  var _iterator36 = _createForOfIteratorHelper(rootTypes),\n      _step36;\n\n  try {\n    for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n      var rootType = _step36.value;\n      visitOutputType(visitedTypes, pruningContext, rootType);\n    }\n  } catch (err) {\n    _iterator36.e(err);\n  } finally {\n    _iterator36.f();\n  }\n\n  var _iterator37 = _createForOfIteratorHelper(schema.getDirectives()),\n      _step37;\n\n  try {\n    for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n      var directive = _step37.value;\n\n      var _iterator38 = _createForOfIteratorHelper(directive.args),\n          _step38;\n\n      try {\n        for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n          var arg = _step38.value;\n          var type = getNamedType(arg.type);\n          visitInputType(visitedTypes, pruningContext, type);\n        }\n      } catch (err) {\n        _iterator38.e(err);\n      } finally {\n        _iterator38.f();\n      }\n    }\n  } catch (err) {\n    _iterator37.e(err);\n  } finally {\n    _iterator37.f();\n  }\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nfunction mergeDeep(sources) {\n  var respectPrototype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var target = sources[0] || {};\n  var output = {};\n\n  if (respectPrototype) {\n    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));\n  }\n\n  var _iterator39 = _createForOfIteratorHelper(sources),\n      _step39;\n\n  try {\n    for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n      var source = _step39.value;\n\n      if (isObject(target) && isObject(source)) {\n        if (respectPrototype) {\n          var outputPrototype = Object.getPrototypeOf(output);\n          var sourcePrototype = Object.getPrototypeOf(source);\n\n          if (sourcePrototype) {\n            var _iterator40 = _createForOfIteratorHelper(Object.getOwnPropertyNames(sourcePrototype)),\n                _step40;\n\n            try {\n              for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n                var key = _step40.value;\n                var descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);\n\n                if (isSome(descriptor)) {\n                  Object.defineProperty(outputPrototype, key, descriptor);\n                }\n              }\n            } catch (err) {\n              _iterator40.e(err);\n            } finally {\n              _iterator40.f();\n            }\n          }\n        }\n\n        for (var _key2 in source) {\n          if (isObject(source[_key2])) {\n            if (!(_key2 in output)) {\n              Object.assign(output, _defineProperty({}, _key2, source[_key2]));\n            } else {\n              output[_key2] = mergeDeep([output[_key2], source[_key2]], respectPrototype);\n            }\n          } else {\n            Object.assign(output, _defineProperty({}, _key2, source[_key2]));\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator39.e(err);\n  } finally {\n    _iterator39.f();\n  }\n\n  return output;\n}\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction parseSelectionSet(selectionSet, options) {\n  var query = parse(selectionSet, options).definitions[0];\n  return query.selectionSet;\n}\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\n\n\nfunction getResponseKeyFromInfo(info) {\n  return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n\nfunction appendObjectFields(schema, typeName, additionalFields) {\n  if (schema.getType(typeName) == null) {\n    return addTypes(schema, [new GraphQLObjectType({\n      name: typeName,\n      fields: additionalFields\n    })]);\n  }\n\n  return mapSchema(schema, _defineProperty({}, MapperKind.OBJECT_TYPE, function (type) {\n    if (type.name === typeName) {\n      var config = type.toConfig();\n      var originalFieldConfigMap = config.fields;\n      var newFieldConfigMap = {};\n\n      for (var fieldName in originalFieldConfigMap) {\n        newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];\n      }\n\n      for (var _fieldName4 in additionalFields) {\n        newFieldConfigMap[_fieldName4] = additionalFields[_fieldName4];\n      }\n\n      return correctASTNodes(new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n        fields: newFieldConfigMap\n      })));\n    }\n  }));\n}\n\nfunction removeObjectFields(schema, typeName, testFn) {\n  var removedFields = {};\n  var newSchema = mapSchema(schema, _defineProperty({}, MapperKind.OBJECT_TYPE, function (type) {\n    if (type.name === typeName) {\n      var config = type.toConfig();\n      var originalFieldConfigMap = config.fields;\n      var newFieldConfigMap = {};\n\n      for (var fieldName in originalFieldConfigMap) {\n        var originalFieldConfig = originalFieldConfigMap[fieldName];\n\n        if (testFn(fieldName, originalFieldConfig)) {\n          removedFields[fieldName] = originalFieldConfig;\n        } else {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        }\n      }\n\n      return correctASTNodes(new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n        fields: newFieldConfigMap\n      })));\n    }\n  }));\n  return [newSchema, removedFields];\n}\n\nfunction selectObjectFields(schema, typeName, testFn) {\n  var selectedFields = {};\n  mapSchema(schema, _defineProperty({}, MapperKind.OBJECT_TYPE, function (type) {\n    if (type.name === typeName) {\n      var config = type.toConfig();\n      var originalFieldConfigMap = config.fields;\n\n      for (var fieldName in originalFieldConfigMap) {\n        var originalFieldConfig = originalFieldConfigMap[fieldName];\n\n        if (testFn(fieldName, originalFieldConfig)) {\n          selectedFields[fieldName] = originalFieldConfig;\n        }\n      }\n    }\n\n    return undefined;\n  }));\n  return selectedFields;\n}\n\nfunction modifyObjectFields(schema, typeName, testFn, newFields) {\n  var removedFields = {};\n  var newSchema = mapSchema(schema, _defineProperty({}, MapperKind.OBJECT_TYPE, function (type) {\n    if (type.name === typeName) {\n      var config = type.toConfig();\n      var originalFieldConfigMap = config.fields;\n      var newFieldConfigMap = {};\n\n      for (var fieldName in originalFieldConfigMap) {\n        var originalFieldConfig = originalFieldConfigMap[fieldName];\n\n        if (testFn(fieldName, originalFieldConfig)) {\n          removedFields[fieldName] = originalFieldConfig;\n        } else {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        }\n      }\n\n      for (var _fieldName5 in newFields) {\n        var fieldConfig = newFields[_fieldName5];\n        newFieldConfigMap[_fieldName5] = fieldConfig;\n      }\n\n      return correctASTNodes(new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n        fields: newFieldConfigMap\n      })));\n    }\n  }));\n  return [newSchema, removedFields];\n}\n\nfunction renameType(type, newTypeName) {\n  if (isObjectType(type)) {\n    return new GraphQLObjectType(_objectSpread(_objectSpread({}, type.toConfig()), {}, {\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : _objectSpread(_objectSpread({}, type.astNode), {}, {\n        name: _objectSpread(_objectSpread({}, type.astNode.name), {}, {\n          value: newTypeName\n        })\n      }),\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          name: _objectSpread(_objectSpread({}, node.name), {}, {\n            value: newTypeName\n          })\n        });\n      })\n    }));\n  } else if (isInterfaceType(type)) {\n    return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, type.toConfig()), {}, {\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : _objectSpread(_objectSpread({}, type.astNode), {}, {\n        name: _objectSpread(_objectSpread({}, type.astNode.name), {}, {\n          value: newTypeName\n        })\n      }),\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          name: _objectSpread(_objectSpread({}, node.name), {}, {\n            value: newTypeName\n          })\n        });\n      })\n    }));\n  } else if (isUnionType(type)) {\n    return new GraphQLUnionType(_objectSpread(_objectSpread({}, type.toConfig()), {}, {\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : _objectSpread(_objectSpread({}, type.astNode), {}, {\n        name: _objectSpread(_objectSpread({}, type.astNode.name), {}, {\n          value: newTypeName\n        })\n      }),\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          name: _objectSpread(_objectSpread({}, node.name), {}, {\n            value: newTypeName\n          })\n        });\n      })\n    }));\n  } else if (isInputObjectType(type)) {\n    return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, type.toConfig()), {}, {\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : _objectSpread(_objectSpread({}, type.astNode), {}, {\n        name: _objectSpread(_objectSpread({}, type.astNode.name), {}, {\n          value: newTypeName\n        })\n      }),\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          name: _objectSpread(_objectSpread({}, node.name), {}, {\n            value: newTypeName\n          })\n        });\n      })\n    }));\n  } else if (isEnumType(type)) {\n    return new GraphQLEnumType(_objectSpread(_objectSpread({}, type.toConfig()), {}, {\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : _objectSpread(_objectSpread({}, type.astNode), {}, {\n        name: _objectSpread(_objectSpread({}, type.astNode.name), {}, {\n          value: newTypeName\n        })\n      }),\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          name: _objectSpread(_objectSpread({}, node.name), {}, {\n            value: newTypeName\n          })\n        });\n      })\n    }));\n  } else if (isScalarType(type)) {\n    return new GraphQLScalarType(_objectSpread(_objectSpread({}, type.toConfig()), {}, {\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : _objectSpread(_objectSpread({}, type.astNode), {}, {\n        name: _objectSpread(_objectSpread({}, type.astNode.name), {}, {\n          value: newTypeName\n        })\n      }),\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(function (node) {\n        return _objectSpread(_objectSpread({}, node), {}, {\n          name: _objectSpread(_objectSpread({}, node.name), {}, {\n            value: newTypeName\n          })\n        });\n      })\n    }));\n  }\n\n  throw new Error(\"Unknown type \".concat(type, \".\"));\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\n\n\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n  var $return;\n  var abruptClose;\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n\n    abruptClose = function abruptClose(error) {\n      var rethrow = function rethrow() {\n        return Promise.reject(error);\n      };\n\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result) {\n    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  var mapReject;\n\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    var reject = rejectCallback;\n\n    mapReject = function mapReject(error) {\n      return asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n    };\n  }\n\n  return _defineProperty({\n    next: function next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n    return: function _return() {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    throw: function _throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n\n      return Promise.reject(error).catch(abruptClose);\n    }\n  }, Symbol.asyncIterator, function () {\n    return this;\n  });\n}\n\nfunction asyncMapValue(value, callback) {\n  return new Promise(function (resolve) {\n    return resolve(callback(value));\n  });\n}\n\nfunction iteratorResult(value) {\n  return {\n    value: value,\n    done: false\n  };\n}\n\nfunction updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {\n  argumentNodes[argName] = {\n    kind: Kind.ARGUMENT,\n    name: {\n      kind: Kind.NAME,\n      value: argName\n    },\n    value: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    }\n  };\n  variableDefinitionsMap[varName] = {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    },\n    type: astFromType(type)\n  };\n\n  if (value !== undefined) {\n    variableValues[varName] = value;\n    return;\n  } // including the variable in the map with value of `undefined`\n  // will actually be translated by graphql-js into `null`\n  // see https://github.com/graphql/graphql-js/issues/2533\n\n\n  if (varName in variableValues) {\n    delete variableValues[varName];\n  }\n}\n\nfunction createVariableNameGenerator(variableDefinitionMap) {\n  var varCounter = 0;\n  return function (argName) {\n    var varName;\n\n    do {\n      varName = \"_v\".concat((varCounter++).toString(), \"_\").concat(argName);\n    } while (varName in variableDefinitionMap);\n\n    return varName;\n  };\n}\n\nfunction implementsAbstractType(schema, typeA, typeB) {\n  if (typeB == null || typeA == null) {\n    return false;\n  } else if (typeA === typeB) {\n    return true;\n  } else if (isCompositeType(typeA) && isCompositeType(typeB)) {\n    return doTypesOverlap(schema, typeA, typeB);\n  }\n\n  return false;\n}\n\nfunction relocatedError(originalError, path) {\n  return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\n\nfunction observableToAsyncIterable(observable) {\n  var pullQueue = [];\n  var pushQueue = [];\n  var listening = true;\n\n  var pushValue = function pushValue(value) {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value: value,\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value: value,\n        done: false\n      });\n    }\n  };\n\n  var pushError = function pushError(error) {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    }\n  };\n\n  var pushDone = function pushDone() {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        done: true\n      });\n    } else {\n      pushQueue.push({\n        done: true\n      });\n    }\n  };\n\n  var pullValue = function pullValue() {\n    return new Promise(function (resolve) {\n      if (pushQueue.length !== 0) {\n        var element = pushQueue.shift(); // either {value: {errors: [...]}} or {value: ...}\n\n        resolve(element);\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n  };\n\n  var subscription = observable.subscribe({\n    next: function next(value) {\n      pushValue(value);\n    },\n    error: function error(err) {\n      pushError(err);\n    },\n    complete: function complete() {\n      pushDone();\n    }\n  });\n\n  var emptyQueue = function emptyQueue() {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n\n      var _iterator41 = _createForOfIteratorHelper(pullQueue),\n          _step41;\n\n      try {\n        for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n          var resolve = _step41.value;\n          resolve({\n            value: undefined,\n            done: true\n          });\n        }\n      } catch (err) {\n        _iterator41.e(err);\n      } finally {\n        _iterator41.f();\n      }\n\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n\n  return _defineProperty({\n    next: function next() {\n      // return is a defined method, so it is safe to call it.\n      return listening ? pullValue() : this.return();\n    },\n    return: function _return() {\n      emptyQueue();\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    throw: function _throw(error) {\n      emptyQueue();\n      return Promise.reject(error);\n    }\n  }, Symbol.asyncIterator, function () {\n    return this;\n  });\n}\n\nfunction getOperationASTFromDocument(documentNode, operationName) {\n  var doc = getOperationAST(documentNode, operationName);\n\n  if (!doc) {\n    throw new Error(\"Cannot infer operation \".concat(operationName || ''));\n  }\n\n  return doc;\n}\n\nvar getOperationASTFromRequest = memoize1(function getOperationASTFromRequest(request) {\n  return getOperationASTFromDocument(request.document, request.operationName);\n}); // Taken from GraphQL-JS v16 for backwards compat\n\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  var _iterator42 = _createForOfIteratorHelper(selectionSet.selections),\n      _step42;\n\n  try {\n    for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n      var selection = _step42.value;\n\n      switch (selection.kind) {\n        case Kind.FIELD:\n          {\n            if (!shouldIncludeNode(variableValues, selection)) {\n              continue;\n            }\n\n            var name = getFieldEntryKey(selection);\n            var fieldList = fields.get(name);\n\n            if (fieldList !== undefined) {\n              fieldList.push(selection);\n            } else {\n              fields.set(name, [selection]);\n            }\n\n            break;\n          }\n\n        case Kind.INLINE_FRAGMENT:\n          {\n            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n              continue;\n            }\n\n            collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n            break;\n          }\n\n        case Kind.FRAGMENT_SPREAD:\n          {\n            var fragName = selection.name.value;\n\n            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n              continue;\n            }\n\n            visitedFragmentNames.add(fragName);\n            var fragment = fragments[fragName];\n\n            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n              continue;\n            }\n\n            collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n            break;\n          }\n      }\n    }\n  } catch (err) {\n    _iterator42.e(err);\n  } finally {\n    _iterator42.f();\n  }\n\n  return fields;\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\n\nfunction shouldIncludeNode(variableValues, node) {\n  var skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n    return false;\n  }\n\n  var include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  var typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  var conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    var possibleTypes = schema.getPossibleTypes(conditionalType);\n    return possibleTypes.includes(type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n\nvar collectSubFields = memoize5(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {\n  var subFieldNodes = new Map();\n  var visitedFragmentNames = new Set();\n\n  var _iterator43 = _createForOfIteratorHelper(fieldNodes),\n      _step43;\n\n  try {\n    for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n      var fieldNode = _step43.value;\n\n      if (fieldNode.selectionSet) {\n        collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n      }\n    }\n  } catch (err) {\n    _iterator43.e(err);\n  } finally {\n    _iterator43.f();\n  }\n\n  return subFieldNodes;\n});\n\nfunction visitData(data, enter, leave) {\n  if (Array.isArray(data)) {\n    return data.map(function (value) {\n      return visitData(value, enter, leave);\n    });\n  } else if (typeof data === 'object') {\n    var newData = enter != null ? enter(data) : data;\n\n    if (newData != null) {\n      for (var key in newData) {\n        var value = newData[key];\n        Object.defineProperty(newData, key, {\n          value: visitData(value, enter, leave)\n        });\n      }\n    }\n\n    return leave != null ? leave(newData) : newData;\n  }\n\n  return data;\n}\n\nfunction visitErrors(errors, visitor) {\n  return errors.map(function (error) {\n    return visitor(error);\n  });\n}\n\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n  var fragments = request.document.definitions.reduce(function (acc, def) {\n    if (def.kind === Kind.FRAGMENT_DEFINITION) {\n      acc[def.name.value] = def;\n    }\n\n    return acc;\n  }, {});\n  var variableValues = request.variables || {};\n  var errorInfo = {\n    segmentInfoMap: new Map(),\n    unpathedErrors: new Set()\n  };\n  var data = result.data;\n  var errors = result.errors;\n  var visitingErrors = errors != null && errorVisitorMap != null;\n  var operationDocumentNode = getOperationASTFromRequest(request);\n\n  if (data != null && operationDocumentNode != null) {\n    result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n  }\n\n  if (errors != null && errorVisitorMap) {\n    result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n  }\n\n  return result;\n}\n\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n  var segmentInfoMap = errorInfo.segmentInfoMap;\n  var unpathedErrors = errorInfo.unpathedErrors;\n  var unpathedErrorVisitor = errorVisitorMap['__unpathed'];\n  return errors.map(function (originalError) {\n    var pathSegmentsInfo = segmentInfoMap.get(originalError);\n    var newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight(function (acc, segmentInfo) {\n      var typeName = segmentInfo.type.name;\n      var typeVisitorMap = errorVisitorMap[typeName];\n\n      if (typeVisitorMap == null) {\n        return acc;\n      }\n\n      var errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n      return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n    }, originalError);\n\n    if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {\n      return unpathedErrorVisitor(newError);\n    }\n\n    return newError;\n  });\n}\n\nfunction visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {\n  var operationRootType = getOperationRootType(schema, operation);\n  var collectedFields = collectFields(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map(), new Set());\n  return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);\n}\n\nfunction visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  var fieldMap = type.getFields();\n  var typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n  var enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n  var newObject = enterObject != null ? enterObject(object) : object;\n  var sortedErrors;\n  var errorMap = null;\n\n  if (errors != null) {\n    sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n    errorMap = sortedErrors.errorMap;\n\n    var _iterator44 = _createForOfIteratorHelper(sortedErrors.unpathedErrors),\n        _step44;\n\n    try {\n      for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n        var error = _step44.value;\n        errorInfo.unpathedErrors.add(error);\n      }\n    } catch (err) {\n      _iterator44.e(err);\n    } finally {\n      _iterator44.f();\n    }\n  }\n\n  var _iterator45 = _createForOfIteratorHelper(fieldNodeMap),\n      _step45;\n\n  try {\n    for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n      var _step45$value = _slicedToArray(_step45.value, 2),\n          responseKey = _step45$value[0],\n          subFieldNodes = _step45$value[1];\n\n      var fieldName = subFieldNodes[0].name.value;\n      var fieldType = fieldName === '__typename' ? TypeNameMetaFieldDef.type : fieldMap[fieldName].type;\n      var newPathIndex = pathIndex + 1;\n      var fieldErrors = void 0;\n\n      if (errorMap) {\n        fieldErrors = errorMap[responseKey];\n\n        if (fieldErrors != null) {\n          delete errorMap[responseKey];\n        }\n\n        addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n      }\n\n      var newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n      updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n    }\n  } catch (err) {\n    _iterator45.e(err);\n  } finally {\n    _iterator45.f();\n  }\n\n  var oldTypename = newObject.__typename;\n\n  if (oldTypename != null) {\n    updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n  }\n\n  if (errorMap) {\n    for (var errorsKey in errorMap) {\n      var _errors = errorMap[errorsKey];\n\n      var _iterator46 = _createForOfIteratorHelper(_errors),\n          _step46;\n\n      try {\n        for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n          var _error = _step46.value;\n          errorInfo.unpathedErrors.add(_error);\n        }\n      } catch (err) {\n        _iterator46.e(err);\n      } finally {\n        _iterator46.f();\n      }\n    }\n  }\n\n  var leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n  return leaveObject != null ? leaveObject(newObject) : newObject;\n}\n\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n  if (typeVisitorMap == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  var fieldVisitor = typeVisitorMap[fieldName];\n\n  if (fieldVisitor == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  var visitedValue = fieldVisitor(newValue);\n\n  if (visitedValue === undefined) {\n    delete object[responseKey];\n    return;\n  }\n\n  object[responseKey] = visitedValue;\n}\n\nfunction visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  return list.map(function (listMember) {\n    return visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo);\n  });\n}\n\nfunction visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex) {\n  var errors = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];\n  var errorInfo = arguments.length > 9 ? arguments[9] : undefined;\n\n  if (value == null) {\n    return value;\n  }\n\n  var nullableType = getNullableType(returnType);\n\n  if (isListType(nullableType)) {\n    return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (isAbstractType(nullableType)) {\n    var finalType = schema.getType(value.__typename);\n    var collectedFields = collectSubFields(schema, fragments, variableValues, finalType, fieldNodes);\n    return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (isObjectType(nullableType)) {\n    var _collectedFields = collectSubFields(schema, fragments, variableValues, nullableType, fieldNodes);\n\n    return visitObjectValue(value, nullableType, _collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  }\n\n  var typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n\n  if (typeVisitorMap == null) {\n    return value;\n  }\n\n  var visitedValue = typeVisitorMap(value);\n  return visitedValue === undefined ? value : visitedValue;\n}\n\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n  var _a;\n\n  var errorMap = Object.create(null);\n  var unpathedErrors = new Set();\n\n  var _iterator47 = _createForOfIteratorHelper(errors),\n      _step47;\n\n  try {\n    for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n      var error = _step47.value;\n      var pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n\n      if (pathSegment == null) {\n        unpathedErrors.add(error);\n        continue;\n      }\n\n      if (pathSegment in errorMap) {\n        errorMap[pathSegment].push(error);\n      } else {\n        errorMap[pathSegment] = [error];\n      }\n    }\n  } catch (err) {\n    _iterator47.e(err);\n  } finally {\n    _iterator47.f();\n  }\n\n  return {\n    errorMap: errorMap,\n    unpathedErrors: unpathedErrors\n  };\n}\n\nfunction addPathSegmentInfo(type, fieldName, pathIndex) {\n  var errors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var errorInfo = arguments.length > 4 ? arguments[4] : undefined;\n\n  var _iterator48 = _createForOfIteratorHelper(errors),\n      _step48;\n\n  try {\n    for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n      var error = _step48.value;\n      var segmentInfo = {\n        type: type,\n        fieldName: fieldName,\n        pathIndex: pathIndex\n      };\n      var pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n\n      if (pathSegmentsInfo == null) {\n        errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n      } else {\n        pathSegmentsInfo.push(segmentInfo);\n      }\n    }\n  } catch (err) {\n    _iterator48.e(err);\n  } finally {\n    _iterator48.f();\n  }\n}\n\nfunction valueMatchesCriteria(value, criteria) {\n  if (value == null) {\n    return value === criteria;\n  } else if (Array.isArray(value)) {\n    return Array.isArray(criteria) && value.every(function (val, index) {\n      return valueMatchesCriteria(val, criteria[index]);\n    });\n  } else if (typeof value === 'object') {\n    return typeof criteria === 'object' && criteria && Object.keys(criteria).every(function (propertyName) {\n      return valueMatchesCriteria(value[propertyName], criteria[propertyName]);\n    });\n  } else if (criteria instanceof RegExp) {\n    return criteria.test(value);\n  }\n\n  return value === criteria;\n}\n\nfunction isAsyncIterable(value) {\n  return typeof value === 'object' && value != null && Symbol.asyncIterator in value;\n}\n\nfunction isDocumentNode(object) {\n  return object && typeof object === 'object' && 'kind' in object && object.kind === Kind.DOCUMENT;\n}\n\nfunction withCancel(asyncIteratorLike, onCancel) {\n  var asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();\n\n  if (!asyncIterator.return) {\n    asyncIterator.return = function () {\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    };\n  }\n\n  var savedReturn = asyncIterator.return.bind(asyncIterator);\n\n  asyncIterator.return = function () {\n    onCancel();\n    return savedReturn();\n  };\n\n  return asyncIterator;\n}\n\nfunction buildFixedSchema(schema, options) {\n  var document = getDocumentNodeFromSchema(schema);\n  return buildASTSchema(document, _objectSpread({}, options || {}));\n}\n\nfunction fixSchemaAst(schema, options) {\n  // eslint-disable-next-line no-undef-init\n  var schemaWithValidAst = undefined;\n\n  if (!schema.astNode || !schema.extensionASTNodes) {\n    schemaWithValidAst = buildFixedSchema(schema, options);\n  }\n\n  if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n    schema.astNode = schemaWithValidAst.astNode;\n  }\n\n  if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n    schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;\n  }\n\n  return schema;\n}\n\nexport { AggregateErrorImpl as AggregateError, MapperKind, addTypes, appendObjectFields, asArray, assertSome, astFromArg, astFromDirective, astFromEnumType, astFromEnumValue, astFromField, astFromInputField, astFromInputObjectType, astFromInterfaceType, astFromObjectType, astFromScalarType, astFromSchema, astFromUnionType, astFromValueUntyped, buildOperationNodeForField, checkValidationErrors, collectComment, collectFields, collectSubFields, compareNodes, compareStrings, correctASTNodes, createDefaultRules, createNamedStub, createStub, createVariableNameGenerator, dedentBlockStringValue, filterSchema, fixSchemaAst, forEachDefaultValue, forEachField, getArgumentValues, getBlockStringIndentation, getBuiltInForStub, getComment, getDefinedRootType, getDeprecatableDirectiveNodes, getDescription, getDirective, getDirectiveInExtensions, getDirectiveNodes, getDirectives, getDirectivesInExtensions, getDocumentNodeFromSchema, getFieldsWithDirectives, getImplementingTypes, getLeadingCommentBlock, getOperationASTFromDocument, getOperationASTFromRequest, getResolversFromSchema, getResponseKeyFromInfo, getRootTypeMap, getRootTypeNames, getRootTypes, healSchema, healTypes, implementsAbstractType, inspect, isAsyncIterable, isDescribable, isDocumentNode, isDocumentString, isNamedStub, isSome, isValidPath, makeDeprecatedDirective, makeDirectiveNode, makeDirectiveNodes, mapAsyncIterator, mapSchema, memoize1, memoize2, memoize2of4, memoize3, memoize4, memoize5, mergeDeep, modifyObjectFields, nodeToString, observableToAsyncIterable, parseGraphQLJSON, parseGraphQLSDL, parseInputValue, parseInputValueLiteral, parseSelectionSet, printComment, printSchemaWithDirectives, printWithComments, pruneSchema, pushComment, relocatedError, removeObjectFields, renameType, resetComments, rewireTypes, selectObjectFields, serializeInputValue, transformCommentsToDescriptions, transformInputValue, updateArgument, validateGraphQlDocuments, valueMatchesCriteria, visitData, visitErrors, visitResult, withCancel };"],"names":["_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","prototype","valueOf","call","e","_isNativeReflectConstruct","result","Super","NewTarget","this","constructor","arguments","apply","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","Object","toString","slice","name","from","test","_unsupportedIterableToArray","length","i","F","s","done","value","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","return","arr","len","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","_objectSpread","target","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","asArray","fns","nodeToString","a","_a","_b","alias","kind","compareNodes","b","customFn","aStr","bStr","String","compareStrings","isSome","input","inspect","formatValue","seenValues","JSON","stringify","concat","previouslySeenValues","includes","toJSON","isJSONable","jsonValue","array","Math","min","remaining","items","join","formatArray","entries","tag","replace","getObjectTag","properties","map","_ref","_ref2","formatObject","formatObjectValue","getDirectivesInExtensions","node","pathToDirectivesInExtensions","undefined","reduce","acc","pathSegment","extensions","astFromType","type","innerType","ofType","Error","astFromValueUntyped","_step9","valuesNodes","_iterator9","itemNode","values","fieldNodes","fieldName","ast","fields","isFinite","stringNum","integerStringRegExp","memoize1","fn","memoize1cache","WeakMap","a1","cachedValue","get","newValue","set","schema","rootTypes","getRootTypes","Set","rootTypeMap","getRootTypeMap","Map","queryType","getQueryType","mutationType","getMutationType","subscriptionType","getSubscriptionType","getDocumentNodeFromSchema","_step10","options","typesMap","getTypeMap","schemaNode","astFromSchema","definitions","directives","getDirectives","_iterator10","directive","astFromDirective","typeName","isPredefinedScalar","isIntrospection","astFromObjectType","astFromInterfaceType","astFromUnionType","astFromInputObjectType","astFromEnumType","astFromScalarType","operationTypeMap","nodes","astNode","extensionASTNodes","_step11","_iterator11","extensionASTNode","_i2","_nodes","operationTypes","_step12","_iterator12","operationTypeDefinitionNode","operation","_step13","_iterator13","_step13$value","operationTypeNode","_operationTypeDefinitionNode","rootType","rootTypeAST","getDirectiveNodes","description","block","_c","_d","args","arg","astFromArg","repeatable","isRepeatable","locations","location","entity","directivesInExtensions","makeDirectiveNodes","_step14","_iterator14","_directives","getDeprecatableDirectiveNodes","directiveNodesBesidesDeprecated","deprecatedDirectiveNode","deprecationReason","makeDirectiveNode","reason","defaultValue","getFields","field","astFromField","interfaces","getInterfaces","iFace","types","getTypes","astFromInputField","getValues","astFromEnumValue","some","directiveNode","specifiedByArgs","url","directiveArguments","_step15","_iterator15","argName","argValue","_argName","_value","directiveValues","directiveNodes","directiveName","arrayOrSingleValue","getDirective","_step16","_iterator16","AggregateErrorImpl","globalThis","AggregateError","AggregateErrorClass","_Error","_super","errors","_this","message","captureStackTrace","commentsRegistry","resetComments","collectComment","entityName","pushComment","_step20","_iterator20","_step21","_iterator21","isFieldDefinitionNode","_step22","_iterator22","argument","comment","getComment","path","printComment","maybeArray","separator","x","hasMultilineItems","str","indent","maybeString","wrap","start","end","printDocASTReducer","Name","leave","Variable","Document","OperationDefinition","varDefs","variableDefinitions","selectionSet","VariableDefinition","_ref5","variable","SelectionSet","_ref6","selections","Field","_ref7","prefix","argsLine","Argument","_ref8","FragmentSpread","_ref9","InlineFragment","_ref10","typeCondition","FragmentDefinition","_ref11","IntValue","_ref12","FloatValue","_ref13","StringValue","_ref14","isDescription","escaped","indexOf","printBlockString","BooleanValue","_ref15","NullValue","EnumValue","_ref16","ListValue","_ref17","ObjectValue","_ref18","ObjectField","_ref19","Directive","_ref20","NamedType","_ref21","ListType","_ref22","NonNullType","_ref23","SchemaDefinition","_ref24","OperationTypeDefinition","_ref25","ScalarTypeDefinition","_ref26","ObjectTypeDefinition","_ref27","FieldDefinition","_ref28","InputValueDefinition","_ref29","InterfaceTypeDefinition","_ref30","UnionTypeDefinition","_ref31","EnumTypeDefinition","_ref32","EnumValueDefinition","_ref33","InputObjectTypeDefinition","_ref34","DirectiveDefinition","_ref35","SchemaExtension","_ref36","ScalarTypeExtension","_ref37","ObjectTypeExtension","_ref38","InterfaceTypeExtension","_ref39","UnionTypeExtension","_ref40","EnumTypeExtension","_ref41","InputObjectTypeExtension","_ref42","printDocASTReducerWithComments","prev","cb","_key","_parent","ancestors","parent","printWithComments","rawValue","getLeadingCommentBlock","dedentBlockStringValue","loc","comments","token","startToken","T","line","reverse","rawString","lines","split","commonIndent","_indent","leadingWhitespace","getBlockStringIndentation","isBlank","shift","pop","MapperKind","getObjectTypeFromTypeMap","typeMap","maybeObjectType","rewireTypes","originalTypeMap","referenceTypeMap","create","newTypeMap","_typeName","namedType","startsWith","newName","_typeName2","rewireNamedType","newDirectives","directiveConfig","toConfig","rewireArgs","rewireDirective","rewiredArgs","rewiredArgType","rewireType","config","newConfig","rewireFields","rewireNamedTypes","_config","_newConfig","_config2","_newConfig2","_config3","_newConfig3","rewiredFields","rewiredFieldType","rewireInputFields","enumConfig","scalarConfig","namedTypes","_step24","rewiredTypes","_iterator24","rewiredType","_rewiredType","_rewiredType2","isNamedStub","getBuiltInForStub","transformInputValue","inputLeafValueTransformer","inputObjectValueTransformer","nullableType","listMember","serializeInputValue","t","v","serialize","parseInputValue","parseValue","mapSchema","schemaMapper","mapArguments","mapFields","mapTypes","mapDefaultValues","mapEnumValues","originalDirectives","mapDirectives","_rewireTypes","query","mutation","subscription","testFn","originalType","typeMapper","getTypeMapper","maybeNewType","enumValueMapper","ENUM_VALUE","getEnumValueMapper","ENUM_TYPE","originalEnumValueConfigMap","newEnumValueConfigMap","externalValue","originalEnumValueConfig","mappedEnumValue","_mappedEnumValue","newExternalValue","newEnumValueConfig","correctASTNodes","ARGUMENT","argumentConfig","getNewType","INPUT_OBJECT_FIELD","inputFieldConfig","newType","_newType","_newType2","fieldMapper","getFieldMapper","originalFieldConfigMap","newFieldConfigMap","originalFieldConfig","mappedField","_mappedField","newFieldName","newFieldConfig","argumentMapper","getArgumentMapper","originalArgumentConfigMap","argumentNames","newArgumentConfigMap","_i3","_argumentNames","argumentName","originalArgumentConfig","mappedArgument","_mappedArgument","newArgumentName","newArgumentConfig","directiveMapper","DIRECTIVE","getDirectiveMapper","_step25","_iterator25","mappedDirective","specifiers","getType","TYPE","COMPOSITE_TYPE","OBJECT_TYPE","ROOT_OBJECT","QUERY","MUTATION","SUBSCRIPTION","INPUT_OBJECT_TYPE","ABSTRACT_TYPE","INTERFACE_TYPE","UNION_TYPE","SCALAR_TYPE","getTypeSpecifiers","stack","FIELD","COMPOSITE_FIELD","OBJECT_FIELD","ROOT_FIELD","QUERY_ROOT_FIELD","MUTATION_ROOT_FIELD","SUBSCRIPTION_ROOT_FIELD","INTERFACE_FIELD","getFieldSpecifiers","fieldConfig","_config4","_fields","_fieldName","_fieldConfig","_config5","_fields2","_fieldName2","_fieldConfig2","_config6","enumKey","enumValueConfig","healSchema","actualNamedTypeMap","actualName","_typeName3","_namedType2","_step26","_iterator26","decl","healType","_typeName4","_namedType3","healNamedType","_typeName5","healFields","healInterfaces","healUnderlyingTypes","healInputFields","fieldMap","_i4","_Object$entries2","_Object$entries2$_i","splice","iface","_i5","_Object$entries3","_Object$entries3$_i","healedType","_healedType","officialType","healTypes","forEachField","forEachDefaultValue","_step28","_iterator28","_fields3","_fieldName3","_field","pruneSchema","pruningContext","unusedTypes","implementations","_step32","_iterator32","getImplementations","visitTypes","skipPruning","skipEmptyCompositeTypePruning","skipUnusedTypesPruning","skipEmptyUnionPruning","_implementations","skipUnimplementedInterfacesPruning","visitOutputType","visitedTypes","_step33","_iterator33","visitInputType","_step34","_iterator34","_step35","_iterator35","_step36","_iterator36","_step37","_iterator37","_step38","_iterator38","mergeDeep","sources","respectPrototype","output","setPrototypeOf","getPrototypeOf","_step39","_iterator39","isObject","outputPrototype","sourcePrototype","_step40","_iterator40","getOwnPropertyNames","descriptor","_key2","assign","item","request","documentNode","operationName","doc","getOperationASTFromDocument","document","collectFields","fragments","variableValues","runtimeType","visitedFragmentNames","_step42","_iterator42","selection","shouldIncludeNode","fieldList","doesFragmentConditionMatch","fragName","has","add","fragment","skip","include","typeConditionNode","conditionalType","getPossibleTypes","memoize5Cache","_step43","subFieldNodes","_iterator43","fieldNode","isDocumentNode"],"sourceRoot":""}