{
    "componentChunkName": "component---src-templates-doc-tsx",
    "path": "/learn/authorization/",
    "result": {"data":{"doc":{"frontmatter":{"title":"Authorization","heroText":null,"date":null,"permalink":"/learn/authorization/","byline":null,"guestBio":null,"sublinks":null,"layout":"docs","tags":null},"id":"44257d7e-1f51-598b-b60f-33b95abcff71","rawMarkdownBody":"\n> 비즈니스 로직 계층에 권한 부여 로직 위임\n\nAuthorization is a type of business logic that describes whether a given user/session/context has permission to perform an action or see a piece of data. For example:\n\n_“Only authors can see their drafts”_\n\nEnforcing this kind of behavior should happen in the [business logic layer](/learn/thinking-in-graphs/#business-logic-layer). It is tempting to place authorization logic in the GraphQL layer like so:\n\n```javascript\nvar postType = new GraphQLObjectType({\n  name: ‘Post’,\n  fields: {\n    body: {\n      type: GraphQLString,\n      resolve: (post, args, context, { rootValue }) => {\n        // return the post body only if the user is the post's author\n        if (context.user && (context.user.id === post.authorId)) {\n          return post.body;\n        }\n        return null;\n      }\n    }\n  }\n});\n```\n\nNotice that we define “author owns a post\" by checking whether the post's `authorId` field equals the current user’s `id`. Can you spot the problem? We would need to duplicate this code for each entry point into the service. Then if the authorization logic is not kept perfectly in sync, users could see different data depending on which API they use. Yikes! We can avoid that by having a [single source of truth](/learn/thinking-in-graphs/#business-logic-layer) for authorization.\n\nDefining authorization logic inside the resolver is fine when learning GraphQL or prototyping. However, for a production codebase, delegate authorization logic to the business logic layer. Here’s an example:\n\n```javascript\n//Authorization logic lives inside postRepository\nvar postRepository = require('postRepository');\n\nvar postType = new GraphQLObjectType({\n  name: ‘Post’,\n  fields: {\n    body: {\n      type: GraphQLString,\n      resolve: (post, args, context, { rootValue }) => {\n        return postRepository.getBody(context.user, post);\n      }\n    }\n  }\n});\n```\n\nIn the example above, we see that the business logic layer requires the caller to provide a user object. If you are using GraphQL.js, the User object should be populated on the `context` argument or `rootValue` in the fourth argument of the resolver.\n\nWe recommend passing a fully-hydrated User object instead of an opaque token or API key to your business logic layer. This way, we can handle the distinct concerns of [authentication](/graphql-js/authentication-and-express-middleware/) and authorization in different stages of the request processing pipeline.\n"},"nextDoc":{"frontmatter":{"title":"Pagination","permalink":"/learn/pagination/"}}},"pageContext":{"permalink":"/learn/authorization/","nextPermalink":"/learn/pagination/","sideBarData":[{"name":"Learn","links":[{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Introduction to GraphQL","permalink":"/learn/","next":"/learn/queries/","category":"Learn","sublinks":null,"sidebarTitle":"Introduction","date":null,"tags":null},"id":"26b5d162-6d81-5127-b220-ac8d4ba7b50b"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Queries.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Queries and Mutations","permalink":"/learn/queries/","next":"/learn/schema/","category":"Learn","sublinks":"Fields,Arguments,Aliases,Fragments,Operation Name,Variables,Directives,Mutations,Inline Fragments","sidebarTitle":null,"date":null,"tags":null},"id":"2eb9e956-93df-5ac2-a377-5053865245d8"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Schema.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Schemas and Types","permalink":"/learn/schema/","next":"/learn/validation/","category":"Learn","sublinks":"Type System,Type Language,Object Types and Fields,Arguments,The Query and Mutation Types,Scalar Types,Enumeration Types,Lists and Non-Null,Interfaces,Union Types,Input Types","sidebarTitle":null,"date":null,"tags":null},"id":"2a3f85f6-2e2b-52be-8cea-ed6d4d9c5ca8"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Validation.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Validation","permalink":"/learn/validation/","next":"/learn/execution/","category":"Learn","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"d3cc6cbf-db61-5cf4-8cd9-53d2efc118ad"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Execution.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Execution","permalink":"/learn/execution/","next":"/learn/thinking-in-graphs/","category":"Learn","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"3304be94-c7e2-5202-9dac-3d26f1bf7d54"}]},{"name":"Best Practices","links":[{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-ThinkingInGraphs.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Thinking in Graphs","permalink":"/learn/thinking-in-graphs/","next":"/learn/serving-over-http/","category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"3dd681cd-ee1c-5881-a8c3-74382dc90a52"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-ServingOverHTTP.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Serving over HTTP","permalink":"/learn/serving-over-http/","next":"/learn/authorization/","category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"a95a9670-790f-54d4-9902-b04335bd85d2"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-Authorization.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Authorization","permalink":"/learn/authorization/","next":"/learn/pagination/","category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"44257d7e-1f51-598b-b60f-33b95abcff71"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-Pagination.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Pagination","permalink":"/learn/pagination/","next":null,"category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"1e6ffc19-7088-59a2-9d74-ad0f09483578"}]}],"sourcePath":"src/content/learn/BestPractice-Authorization.md"}},
    "staticQueryHashes": ["1581580458","2616045547"]}