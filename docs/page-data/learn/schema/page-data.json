{
    "componentChunkName": "component---src-templates-doc-tsx",
    "path": "/learn/schema/",
    "result": {"data":{"doc":{"frontmatter":{"title":"Schemas and Types","heroText":null,"date":null,"permalink":"/learn/schema/","byline":null,"guestBio":null,"sublinks":"Type System,Type Language,Object Types and Fields,Arguments,The Query and Mutation Types,Scalar Types,Enumeration Types,Lists and Non-Null,Interfaces,Union Types,Input Types","layout":"docs","tags":null},"id":"2a3f85f6-2e2b-52be-8cea-ed6d4d9c5ca8","rawMarkdownBody":"\nGraphQL 서비스는 해당 서비스에서 쿼리할 수 있는 가능한 데이터 집합을 완전히 설명하는 유형 집합을 정의합니다. 그런 다음 쿼리가 들어오면 해당 스키마에 대해 유효성이 검사되고 실행됩니다.\n\n### Type language\n\nGraphQL services can be written in any language.\n\nWe'll use the \"GraphQL schema language\" - it's similar to the query language.\n\n### Object types and fields\n\nThe most basic components of a GraphQL schema are object types:\n\n```graphql\ntype Character {\n  name: String!\n  appearsIn: [Episode!]!\n}\n```\n\nThe language is pretty readable, but let's go over it so that we can have a shared vocabulary:\n\n- `Character`는 a *GraphQL Object Type*으로 some fields를 가질 수 있다. 대부분 스키마 타입은 object type일 것이다.\n- `name` and `appearsIn`은 `Character` type의 _fields_ 이다. 모든 `Character` type의 부분에서 나타날 수 있다.\n- `String` is one of the built-in _scalar_ types\n- `String!` 필드는 _non-nullable_ 이다.\n- `[Episode!]!`는 `Episode` objects array이다. 또한 *non-nullable*이다(with zero or more items).\n\n### Arguments\n\nEvery field on a GraphQL object type can have zero or more arguments.\n\n```graphql\ntype Starship {\n  id: ID!\n  name: String!\n  length(unit: LengthUnit = METER): Float\n}\n```\n\n### The Query and Mutation types\n\n스키마의 대부분의 유형은 object types 이지만 두 가지 special type이 있습니다.\n\nGraphQL 쿼리의 진입점을 정의하기 때문에 특별합니다. Mutation도 Query와 동일하게 정의되고 동작합니다.\n\n```graphql\nschema {\n  query: Query\n  mutation: Mutation\n}\n```\n\n```graphql\n# { \"graphiql\": true }\nquery {\n  hero {\n    name\n  }\n  droid(id: \"2000\") {\n    name\n  }\n}\n```\n\n```graphql\ntype Query {\n  hero(episode: Episode): Character\n  droid(id: ID!): Droid\n}\n```\n\n### Scalar types\n\nthose fields don't have any sub-fields - they are the leaves of the query.\n\nIn the following query, the `name` and `appearsIn` fields will resolve to scalar types:\n\n```graphql\n# { \"graphiql\": true }\n{\n  hero {\n    name\n    appearsIn\n  }\n}\n```\n\nGraphQL comes with a set of default scalar types out of the box:\n\n- `Int`: A signed 32‐bit integer.\n- `Float`: A signed double-precision floating-point value.\n- `String`: A UTF‐8 character sequence.\n- `Boolean`: `true` or `false`.\n- `ID`: The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a String; however, defining it as an `ID` signifies that it is not intended to be human‐readable.\n\n사용자 지정 스칼라 유형을 지정하는 방법도 있습니다. 그런 다음 해당 유형을 직렬화, 역직렬화 및 검증하는 방법을 정의하는 것은 구현에 달려 있습니다.\n\n```graphql\nscalar Date\n```\n\n### Enumeration types\n\n```graphql\nenum Episode {\n  NEWHOPE\n  EMPIRE\n  JEDI\n}\n```\n\nThis means that wherever we use the type `Episode` in our schema, we expect it to be exactly one of `NEWHOPE`, `EMPIRE`, or `JEDI`.\n\n### Lists and Non-Null\n\n```graphql\ntype Character {\n  name: String!\n  appearsIn: [Episode]!\n}\n```\n\n여기에서는 `String` 유형을 사용하고 느낌표 !를 추가하여 *Non-Null*로 표시합니다.\n\n해당 인수로 null 값이 전달되면 GraphQL 서버가 유효성 검사 오류를 반환합니다.\n\n```graphql\n# { \"graphiql\": true, \"variables\": { \"id\": null } }\nquery DroidById($id: ID!) {\n  droid(id: $id) {\n    name\n  }\n}\n```\n\n```graphql\nmyField: [String!]\n```\n\nThis means that the _list itself_ can be null, but it can't have any null members. For example, in JSON:\n\n```js\nmyField: null // valid\nmyField: [] // valid\nmyField: [\"a\", \"b\"] // valid\nmyField: [\"a\", null, \"b\"] // error\n```\n\nNow, let's say we defined a Non-Null List of Strings:\n\n```graphql\nmyField: [String]!\n```\n\nThis means that the list itself cannot be null, but it can contain null values:\n\n```js\nmyField: null // error\nmyField: [] // valid\nmyField: [\"a\", \"b\"] // valid\nmyField: [\"a\", null, \"b\"] // valid\n```\n\nYou can arbitrarily nest any number of Non-Null and List modifiers, according to your needs.\n\n### Interfaces\n\nFor example, you could have an interface `Character` that represents any character in the Star Wars trilogy:\n\n```graphql\ninterface Character {\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n}\n```\n\n```graphql\ntype Human implements Character {\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n  starships: [Starship]\n  totalCredits: Int\n}\n\ntype Droid implements Character {\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n  primaryFunction: String\n}\n```\n\nFor example, note that the following query produces an error:\n\n```graphql\n# { \"graphiql\": true, \"variables\": { \"ep\": \"JEDI\" } }\nquery HeroForEpisode($ep: Episode!) {\n  hero(episode: $ep) {\n    name\n    primaryFunction\n  }\n}\n```\n\nTo ask for a field on a specific object type, you need to use an inline fragment:\n\n```graphql\n# { \"graphiql\": true, \"variables\": { \"ep\": \"JEDI\" } }\nquery HeroForEpisode($ep: Episode!) {\n  hero(episode: $ep) {\n    name\n    ... on Droid {\n      primaryFunction\n    }\n  }\n}\n```\n\n### Union types\n\n```graphql\nunion SearchResult = Human | Droid | Starship\n```\n\n```graphql\n# { \"graphiql\": true}\n{\n  search(text: \"an\") {\n    __typename\n    ... on Human {\n      name\n      height\n    }\n    ... on Droid {\n      name\n      primaryFunction\n    }\n    ... on Starship {\n      name\n      length\n    }\n  }\n}\n```\n\n```graphql\n{\n  search(text: \"an\") {\n    __typename\n    ... on Character {\n      name\n    }\n    ... on Human {\n      height\n    }\n    ... on Droid {\n      primaryFunction\n    }\n    ... on Starship {\n      name\n      length\n    }\n  }\n}\n```\n\n`Starship`의 경우 `Character`가 아니기 때문에 `name`을 빼면 결과에 나오지 않는다.\n\n### Input types\n\nIn the GraphQL schema language, input types look exactly the same as regular object types, but with the keyword `input` instead of `type`:\n\n```graphql\ninput ReviewInput {\n  stars: Int!\n  commentary: String\n}\n```\n\nHere is how you could use the input object type in a mutation:\n\n```graphql\n# { \"graphiql\": true, \"variables\": { \"ep\": \"JEDI\", \"review\": { \"stars\": 5, \"commentary\": \"This is a great movie!\" } } }\nmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n  createReview(episode: $ep, review: $review) {\n    stars\n    commentary\n  }\n}\n```\n"},"nextDoc":{"frontmatter":{"title":"Validation","permalink":"/learn/validation/"}}},"pageContext":{"permalink":"/learn/schema/","nextPermalink":"/learn/validation/","sideBarData":[{"name":"Learn","links":[{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Introduction to GraphQL","permalink":"/learn/","next":"/learn/queries/","category":"Learn","sublinks":null,"sidebarTitle":"Introduction","date":null,"tags":null},"id":"26b5d162-6d81-5127-b220-ac8d4ba7b50b"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Queries.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Queries and Mutations","permalink":"/learn/queries/","next":"/learn/schema/","category":"Learn","sublinks":"Fields,Arguments,Aliases,Fragments,Operation Name,Variables,Directives,Mutations,Inline Fragments","sidebarTitle":null,"date":null,"tags":null},"id":"2eb9e956-93df-5ac2-a377-5053865245d8"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Schema.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Schemas and Types","permalink":"/learn/schema/","next":"/learn/validation/","category":"Learn","sublinks":"Type System,Type Language,Object Types and Fields,Arguments,The Query and Mutation Types,Scalar Types,Enumeration Types,Lists and Non-Null,Interfaces,Union Types,Input Types","sidebarTitle":null,"date":null,"tags":null},"id":"2a3f85f6-2e2b-52be-8cea-ed6d4d9c5ca8"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Validation.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Validation","permalink":"/learn/validation/","next":"/learn/execution/","category":"Learn","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"d3cc6cbf-db61-5cf4-8cd9-53d2efc118ad"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Execution.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Execution","permalink":"/learn/execution/","next":"/learn/thinking-in-graphs/","category":"Learn","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"3304be94-c7e2-5202-9dac-3d26f1bf7d54"}]},{"name":"Best Practices","links":[{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-ThinkingInGraphs.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Thinking in Graphs","permalink":"/learn/thinking-in-graphs/","next":"/learn/serving-over-http/","category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"3dd681cd-ee1c-5881-a8c3-74382dc90a52"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-ServingOverHTTP.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Serving over HTTP","permalink":"/learn/serving-over-http/","next":"/learn/authorization/","category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"a95a9670-790f-54d4-9902-b04335bd85d2"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-Authorization.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Authorization","permalink":"/learn/authorization/","next":"/learn/pagination/","category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"44257d7e-1f51-598b-b60f-33b95abcff71"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-Pagination.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Pagination","permalink":"/learn/pagination/","next":null,"category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"1e6ffc19-7088-59a2-9d74-ad0f09483578"}]}],"sourcePath":"src/content/learn/Learn-Schema.md"}},
    "staticQueryHashes": ["1581580458","2616045547"]}