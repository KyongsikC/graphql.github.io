{
    "componentChunkName": "component---src-templates-doc-tsx",
    "path": "/learn/queries/",
    "result": {"data":{"doc":{"frontmatter":{"title":"Queries and Mutations","heroText":null,"date":null,"permalink":"/learn/queries/","byline":null,"guestBio":null,"sublinks":"Fields,Arguments,Aliases,Fragments,Operation Name,Variables,Directives,Mutations,Inline Fragments","layout":"docs","tags":null},"id":"2eb9e956-93df-5ac2-a377-5053865245d8","rawMarkdownBody":"\nOn this page, you'll learn in detail about how to query a GraphQL server.\n\n## Fields\n\n```graphql\n# { \"graphiql\": true }\n{\n  hero {\n    name\n  }\n}\n```\n\n필드는 객체를 참조할 수도 있습니다. 이 경우 해당 개체에 대한 필드의 sub-selection을 만들 수 있습니다.\n\n클라이언트가 classic REST architecture에서 필요로 하는 것처럼 여러 번 왕복하는 대신 한 번의 요청으로 많은 관련 데이터를 가져올 수 있습니다.\n\n```graphql\n# { \"graphiql\": true }\n{\n  hero {\n    name\n    # Queries can have comments!\n    friends {\n      name\n    }\n  }\n}\n```\n\n## Arguments\n\n```graphql\n# { \"graphiql\": true }\n{\n  human(id: \"1000\") {\n    name\n    height\n  }\n}\n```\n\nREST와 같은 시스템에서는 single set of arguments(query parameters and URL segments)만 전달.\n\nGraphQL에서는 모든 필드와 중첩 객체가 고유한 인수 집합을 얻을 수 있으므로 GraphQL을 여러 API 가져오기가 가능합니다.\n\n```graphql\n# { \"graphiql\": true }\n{\n  human(id: \"1000\") {\n    name\n    height(unit: FOOT)\n  }\n}\n```\n\n[Read more about the GraphQL type system here.](/learn/schema)\n\n## Aliases\n\n필드 결과의 이름을 원하는 대로 바꿀 수 있음\n\n별칭을 지정할 수 있으므로 한 번의 요청으로 두 결과를 모두 얻을 수 있음\n\n```graphql\n# { \"graphiql\": true }\n{\n  empireHero: hero(episode: EMPIRE) {\n    name\n  }\n  jediHero: hero(episode: JEDI) {\n    name\n  }\n}\n```\n\n## Fragments\n\n재사용 가능한 단위\n\n```graphql\n# { \"graphiql\": true }\n{\n  leftComparison: hero(episode: EMPIRE) {\n    ...comparisonFields\n  }\n  rightComparison: hero(episode: JEDI) {\n    ...comparisonFields\n  }\n}\n\nfragment comparisonFields on Character {\n  name\n  appearsIn\n  friends {\n    name\n  }\n}\n```\n\n### Using variables inside fragments\n\n선언된 변수에 액세스\n\n```graphql\n# { \"graphiql\": true }\nquery HeroComparison($first: Int = 3) {\n  leftComparison: hero(episode: EMPIRE) {\n    ...comparisonFields\n  }\n  rightComparison: hero(episode: JEDI) {\n    ...comparisonFields\n  }\n}\n\nfragment comparisonFields on Character {\n  name\n  friendsConnection(first: $first) {\n    totalCount\n    edges {\n      node {\n        name\n      }\n    }\n  }\n}\n```\n\n## Operation name\n\n`query` 키워드와 query name을 모두 생략하는 축약형 구문을 사용했지만 프로덕션 앱에서는 코드를 덜 모호하게 만드는 데 사용하는 것이 유용합니다.\n\n문제가 발생하면(네트워크 로그 또는 GraphQL 서버의 로그에 오류가 표시됨, 디버깅 및 서버 측 로깅에 매우 유용) 이름으로 식별하는 것이 더 쉽습니다.\n\n```graphql\n# { \"graphiql\": true }\nquery HeroNameAndFriends {\n  hero {\n    name\n    friends {\n      name\n    }\n  }\n}\n```\n\n## Variables\n\n동적 인수를 쿼리 문자열에 직접 전달하는 것은 좋은 생각이 아닙니다.\n\n그러면 클라이언트 측 코드가 런타임에 쿼리 문자열을 동적으로 조작하고 GraphQL 명세로 serialize해야 하기 때문입니다.\n\n대신 GraphQL에는 쿼리에서 동적 값을 전달하는 방법이 있습니다. 이러한 값을 Variables라고 합니다.\n\nWhen we start working with variables, we need to do three things:\n\n1. 쿼리 값을 `$variableName`으로 바꿉니다.\n2. `$variableName` 변수를 선언\n3. 일반적으로 JSON형태로 변수 값을 전달 `variableName: value`\n\nHere's what it looks like all together:\n\n```graphql\n# { \"graphiql\": true, \"variables\": { \"episode\": \"JEDI\" } }\nquery HeroNameAndFriends($episode: Episode) {\n  hero(episode: $episode) {\n    name\n    friends {\n      name\n    }\n  }\n}\n```\n\n### Default variables\n\n```graphql\nquery HeroNameAndFriends($episode: Episode = JEDI) {\n  hero(episode: $episode) {\n    name\n    friends {\n      name\n    }\n  }\n}\n```\n\n## Directives\n\n변수를 사용하여 쿼리의 구조와 모양을 동적으로 변경하는 방법도 필요할 수 있습니다.\n\nLet's construct a query for such a component:\n\n```graphql\n# { \"graphiql\": true, \"variables\": { \"episode\": \"JEDI\", \"withFriends\": false } }\nquery Hero($episode: Episode, $withFriends: Boolean!) {\n  hero(episode: $episode) {\n    name\n    friends @include(if: $withFriends) {\n      name\n    }\n  }\n}\n```\n\nDirectives은 fields 또는 Fragments에 첨부될 수 있으며 서버가 원하는 방식으로 쿼리 실행에 영향을 줄 수 있습니다.\n\nGraphQL 서버 구현에서 지원해야 하는 정확히 두 개의 지시문이 포함되어 있습니다.\n\n- `@include(if: Boolean)` Only include this field in the result if the argument is `true`.\n- `@skip(if: Boolean)` Skip this field if the argument is `true`.\n\n완전히 새로운 지시문을 정의하여 실험적 기능을 추가할 수도 있습니다.\n\n## Mutations\n\n서버 측 데이터도 수정할 수 있는 방법이 필요합니다.\n\n쿼리를 구현하여 데이터 쓰기할 수도 있지만, Mutations을 통해 명시적으로 보내야 한다는 규칙을 설정하는 것이 유용합니다.쿼리와 마찬가지로 결과 객체 유형을 반환할 수 있습니다.\n\n```graphql\n# { \"graphiql\": true, \"variables\": { \"ep\": \"JEDI\", \"review\": { \"stars\": 5, \"commentary\": \"This is a great movie!\" } } }\nmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n  createReview(episode: $ep, review: $review) {\n    stars\n    commentary\n  }\n}\n```\n\n### Multiple fields in mutations\n\n쿼리와 변형 사이에는 이름 외에 한 가지 중요한 차이점이 있습니다:\n\n**query fields가 parallel로 실행되는 동안 mutation fields는 차례대로 실행됩니다.**\n\n첫 번째는 두 번째가 시작되기 전에 완료되도록 보장하고 race condition이 발생되지 않도록 합니다.\n\n## Inline Fragments\n\nInterface or a union type을 반환하는 필드를 쿼리하는 경우 *inline fragments*을 사용하여 concrete type의 데이터에 액세스해야 합니다.\n\n`hero` field는 에피소드 인수에 따라 `Human` 또는 `Droid`가 될 수 있는 `Character` 유형을 반환합니다. 직접 선택에서는 이름과 같이 `Character` 인터페이스에 존재하는 필드만 요청할 수 있습니다.\n\n```graphql\n# { \"graphiql\": true, \"variables\": { \"ep\": \"JEDI\" } }\nquery HeroForEpisode($ep: Episode!) {\n  hero(episode: $ep) {\n    name\n    ... on Droid {\n      primaryFunction\n    }\n    ... on Human {\n      height\n    }\n  }\n}\n```\n\n### Meta fields\n\n`__typename`을 요청하여 해당 지점의 개체 유형 이름을 가져올 수 있습니다.\n\nGraphQL 서비스는 몇 가지 메타 필드를 제공하며 나머지는 [Introspection](../introspection/) system을 노출하는 데 사용됩니다.\n\n```graphql\n# { \"graphiql\": true}\n{\n  search(text: \"an\") {\n    __typename\n    ... on Human {\n      name\n    }\n    ... on Droid {\n      name\n    }\n    ... on Starship {\n      name\n    }\n  }\n}\n```\n"},"nextDoc":{"frontmatter":{"title":"Schemas and Types","permalink":"/learn/schema/"}}},"pageContext":{"permalink":"/learn/queries/","nextPermalink":"/learn/schema/","sideBarData":[{"name":"Learn","links":[{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Introduction to GraphQL","permalink":"/learn/","next":"/learn/queries/","category":"Learn","sublinks":null,"sidebarTitle":"Introduction","date":null,"tags":null},"id":"26b5d162-6d81-5127-b220-ac8d4ba7b50b"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Queries.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Queries and Mutations","permalink":"/learn/queries/","next":"/learn/schema/","category":"Learn","sublinks":"Fields,Arguments,Aliases,Fragments,Operation Name,Variables,Directives,Mutations,Inline Fragments","sidebarTitle":null,"date":null,"tags":null},"id":"2eb9e956-93df-5ac2-a377-5053865245d8"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Schema.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Schemas and Types","permalink":"/learn/schema/","next":"/learn/validation/","category":"Learn","sublinks":"Type System,Type Language,Object Types and Fields,Arguments,The Query and Mutation Types,Scalar Types,Enumeration Types,Lists and Non-Null,Interfaces,Union Types,Input Types","sidebarTitle":null,"date":null,"tags":null},"id":"2a3f85f6-2e2b-52be-8cea-ed6d4d9c5ca8"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Validation.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Validation","permalink":"/learn/validation/","next":"/learn/execution/","category":"Learn","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"d3cc6cbf-db61-5cf4-8cd9-53d2efc118ad"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/Learn-Execution.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Execution","permalink":"/learn/execution/","next":"/learn/thinking-in-graphs/","category":"Learn","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"3304be94-c7e2-5202-9dac-3d26f1bf7d54"}]},{"name":"Best Practices","links":[{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-ThinkingInGraphs.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Thinking in Graphs","permalink":"/learn/thinking-in-graphs/","next":"/learn/serving-over-http/","category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"3dd681cd-ee1c-5881-a8c3-74382dc90a52"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-ServingOverHTTP.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Serving over HTTP","permalink":"/learn/serving-over-http/","next":"/learn/authorization/","category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"a95a9670-790f-54d4-9902-b04335bd85d2"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-Authorization.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Authorization","permalink":"/learn/authorization/","next":"/learn/pagination/","category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"44257d7e-1f51-598b-b60f-33b95abcff71"},{"fileAbsolutePath":"/Users/ks.choi/graphql.github.io/src/content/learn/BestPractice-Pagination.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Pagination","permalink":"/learn/pagination/","next":null,"category":"Best Practices","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"1e6ffc19-7088-59a2-9d74-ad0f09483578"}]}],"sourcePath":"src/content/learn/Learn-Queries.md"}},
    "staticQueryHashes": ["1581580458","2616045547"]}